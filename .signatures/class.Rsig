package "class" "7.3.14" {
	var ".__NAMESPACE__."
	var ".__S3MethodsTable__."
	var ".noGenerics"
	function ".onUnload"("libpath")
	var ".packageName"
	/**
	 * 
	 *Kohonen's Self-Organizing Maps are a crude form of multidimensional scaling.
	 *
	 */
	exported function "batchSOM"("data", "grid"="somgrid()", "radii", "init")
	/**
	 * 
	 *Condense training set for k-NN classifier
	 *
	 */
	exported function "condense"("train", "class", "store"="sample(seq(n), 1)", "trace"="TRUE")
	/**
	 * 
	 *k-nearest neighbour classification for test set from training set. For
	 *each row of the test set, the \code{k} nearest (in Euclidean distance)
	 *training set vectors are found, and the classification is decided by
	 *majority vote, with ties broken at random. If there are ties for the
	 *\code{k}th nearest vector, all candidates are included in the vote.
	 *
	 */
	exported function "knn"("train", "test", "cl", "k"="1", "l"="0", "prob"="FALSE", "use.all"="TRUE")
	/**
	 * 
	 *k-nearest neighbour cross-validatory classification from training set.
	 *
	 */
	exported function "knn.cv"("train", "cl", "k"="1", "l"="0", "prob"="FALSE", "use.all"="TRUE")
	/**
	 * 
	 *Nearest neighbour classification for test set from training set. For
	 *each row of the test set, the nearest (by Euclidean distance) training
	 *set vector is found, and its classification used. If there is more than
	 *one nearest, a majority vote is used with ties broken at random.
	 *
	 */
	exported function "knn1"("train", "test", "cl")
	/**
	 * 
	 *Moves examples in a codebook to better represent the training set.
	 *
	 */
	exported function "lvq1"("x", "cl", "codebk", "niter"="100 * nrow(codebk$x)", "alpha"="0.03")
	/**
	 * 
	 *Moves examples in a codebook to better represent the training set.
	 *
	 */
	exported function "lvq2"("x", "cl", "codebk", "niter"="100 * nrow(codebk$x)", "alpha"="0.03", "win"="0.3")
	/**
	 * 
	 *Moves examples in a codebook to better represent the training set.
	 *
	 */
	exported function "lvq3"("x", "cl", "codebk", "niter"="100 * nrow(codebk$x)", "alpha"="0.03", "win"="0.3", "epsilon"="0.1")
	/**
	 * 
	 *Construct an initial codebook for LVQ methods.
	 *
	 */
	exported function "lvqinit"("x", "cl", "size", "prior", "k"="5")
	/**
	 * 
	 *Classify a test set by 1-NN from a specified LVQ codebook.
	 *
	 */
	exported function "lvqtest"("codebk", "test")
	/**
	 * 
	 *Multiedit for k-NN classifier
	 *
	 */
	exported function "multiedit"("x", "class", "k"="1", "V"="3", "I"="5", "trace"="TRUE")
	/**
	 * 
	 *Moves examples in a codebook to better represent the training set.
	 *
	 */
	exported function "olvq1"("x", "cl", "codebk", "niter"="40 * nrow(codebk$x)", "alpha"="0.3")
	/**
	 * 
	 * Plotting functions for SOM results.
	 *
	 */
	function "plot.SOM"("x", "...")
	/**
	 * 
	 * Plotting functions for SOM results.
	 *
	 */
	function "plot.somgrid"("x", "type"="p", "...")
	/**
	 * 
	 *Reduce training set for a k-NN classifier. Used after \code{condense}.
	 *
	 */
	exported function "reduce.nn"("train", "ind", "class")
	/**
	 * 
	 *Kohonen's Self-Organizing Maps are a crude form of multidimensional scaling.
	 *
	 */
	exported function "SOM"("data", "grid"="somgrid()", "rlen"="10000", "alpha"="seq(0.05, 0, len = rlen)", "radii"="seq(4, 1, len = rlen)", "init")
	/**
	 * 
	 * Plotting functions for SOM results.
	 *
	 */
	exported function "somgrid"("xdim"="8", "ydim"="6", "topo"="c(\"rectangular\", \"hexagonal\")")
	var "VR_knn"
	var "VR_knn1"
	var "VR_lvq1"
	var "VR_lvq2"
	var "VR_lvq3"
	var "VR_olvq"
	var "VR_onlineSOM"
}
