package "boot" "1.3.18" {
	var ".__NAMESPACE__."
	var ".__S3MethodsTable__."
	var ".packageName"
	/**
	 * 
	 *Calculate equi-tailed two-sided nonparametric approximate bootstrap confidence 
	 *intervals for a parameter, given a set of data and an estimator of the 
	 *parameter, using numerical differentiation.  
	 *
	 */
	exported function "abc.ci"("data", "statistic", "index"="1", "strata"="rep(1, n)", "conf"="0.95", "eps"="0.001/n", "...")
	function "anti.arr"("n", "R", "L", "inds"="seq_len(n)")
	function "antithetic.array"("n", "R", "L", "strata")
	function "balanced.array"("n", "R", "strata")
	function "basic.ci"("t0", "t", "conf"="0.95", "hinv"="function(t) t")
	function "bca.ci"("boot.out", "conf"="0.95", "index"="1", "t0"="", "t"="", "L"="", "h"="function(t) t", "hdot"="function(t) 1", "hinv"="function(t) t", "...")
	/**
	 * 
	 * Generate \code{R} bootstrap replicates of a statistic applied to data.  Both
	 * parametric and nonparametric resampling are possible.  For the nonparametric
	 * bootstrap, possible resampling methods are the ordinary bootstrap, the 
	 * balanced bootstrap, antithetic resampling, and permutation.
	 * For nonparametric multi-sample problems stratified resampling is used:
	 * this is specified by including a vector of strata in the call to boot.
	 * Importance resampling weights may be specified.
	 *
	 */
	exported function "boot"("data", "statistic", "R", "sim"="ordinary", "stype"="c(\"i\", \"f\", \"w\")", "strata"="rep(1, n)", "L"="", "m"="0", "weights"="", "ran.gen"="function(d, p) d", "mle"="", "simple"="FALSE", "...", "parallel"="c(\"no\", \"multicore\", \"snow\")", "ncpus"="getOption(\"boot.ncpus\", 1L)", "cl"="")
	/**
	 * 
	 * This function takes a bootstrap object calculated by one of the
	 * functions \code{boot}, \code{censboot}, or \code{tilt.boot} and
	 * returns the frequency (or index) array for the bootstrap
	 * resamples.
	 *
	 */
	exported function "boot.array"("boot.out", "indices"="FALSE")
	/**
	 * 
	 * This function generates 5 different types of equi-tailed two-sided
	 * nonparametric confidence intervals.  These are the first order normal 
	 * approximation, the basic bootstrap interval, the studentized bootstrap 
	 * interval, the bootstrap percentile interval, and the adjusted bootstrap 
	 * percentile (BCa) interval.  All or a subset of these intervals can be 
	 * generated.  
	 *
	 */
	exported function "boot.ci"("boot.out", "conf"="0.95", "type"="all", "index"="1L:min(2L, length(boot.out$t0))", "var.t0"="", "var.t"="", "t0"="", "t"="", "L"="", "h"="function(t) t", "hdot"="function(t) rep(1, length(t))", "hinv"="function(t) t", "...")
	/**
	 * 
	 * Generate \code{R} bootstrap replicates of a statistic applied to data.  Both
	 * parametric and nonparametric resampling are possible.  For the nonparametric
	 * bootstrap, possible resampling methods are the ordinary bootstrap, the 
	 * balanced bootstrap, antithetic resampling, and permutation.
	 * For nonparametric multi-sample problems stratified resampling is used:
	 * this is specified by including a vector of strata in the call to boot.
	 * Importance resampling weights may be specified.
	 *
	 */
	function "boot.return"("sim", "t0", "t", "strata", "R", "data", "stat", "stype", "call", "seed", "L", "m", "pred.i", "weights", "ran.gen", "mle")
	function "bsample"("x", "...")
	/**
	 * 
	 * Generate \code{R} bootstrap replicates of a statistic applied to data.  Both
	 * parametric and nonparametric resampling are possible.  For the nonparametric
	 * bootstrap, possible resampling methods are the ordinary bootstrap, the 
	 * balanced bootstrap, antithetic resampling, and permutation.
	 * For nonparametric multi-sample problems stratified resampling is used:
	 * this is specified by including a vector of strata in the call to boot.
	 * Importance resampling weights may be specified.
	 *
	 */
	function "c.boot"("...", "recursive"="TRUE")
	function "cens.case"("n", "strata", "R")
	function "cens.resamp"("data", "R", "F.surv", "G.surv", "strata", "index"="c(1, 2)", "cox"="", "sim"="model")
	/**
	 *   
	 *This function applies types of bootstrap resampling which have
	 *been suggested to deal with right-censored data.  It can also do model-based
	 *resampling using a Cox regression model.
	 *
	 */
	function "cens.return"("sim", "t0", "t", "strata", "R", "data", "statistic", "call", "seed")
	function "cens.weird"("data", "surv", "strata")
	/**
	 *   
	 *This function applies types of bootstrap resampling which have
	 *been suggested to deal with right-censored data.  It can also do model-based
	 *resampling using a Cox regression model.
	 *
	 */
	exported function "censboot"("data", "statistic", "R", "F.surv", "G.surv", "strata"="matrix(1, n, 2)", "sim"="ordinary", "cox"="", "index"="c(1, 2)", "...", "parallel"="c(\"no\", \"multicore\", \"snow\")", "ncpus"="getOption(\"boot.ncpus\", 1L)", "cl"="")
	function "const"("w", "eps"="1e-08")
	/**
	 * 
	 * This function will find control variate estimates from a bootstrap
	 * output object.  It can either find the adjusted bias estimate using
	 * post-simulation balancing or it can estimate the bias, variance, third
	 * cumulant and quantiles, using the linear approximation as a control
	 * variate.
	 *
	 */
	exported function "control"("boot.out", "L"="", "distn"="", "index"="1", "t0"="", "t"="", "bias.adj"="FALSE", "alpha"="", "...")
	/**
	 * 
	 *Calculates the weighted correlation given a data set and a set of weights.
	 *
	 */
	exported function "corr"("d", "w"="rep(1, nrow(d))/nrow(d)")
	/**
	 * 
	 *Calculates an estimate of the third cumulant, or skewness, of a vector. 
	 *Also, if more than one vector is specified, a product-moment of order 3 is
	 *estimated. 
	 *
	 */
	exported function "cum3"("a", "b", "c", "unbiased"="TRUE")
	/**
	 * 
	 *This function calculates the estimated K-fold cross-validation prediction 
	 *error for generalized linear models.
	 *
	 */
	exported function "cv.glm"("data", "glmfit", "cost"="function(y, yhat) mean((y - yhat)^2)", "K")
	/**
	 * 
	 *Construct the empirical log likelihood or empirical exponential 
	 *family log likelihood for a mean.
	 */
	exported function "EEF.profile"("y", "tmin"="min(y) + 0.1", "tmax"="max(y) - 0.1", "n.t"="25", "u"="function(y, t) y - t")
	/**
	 * 
	 *Construct the empirical log likelihood or empirical exponential 
	 *family log likelihood for a mean.
	 */
	exported function "EL.profile"("y", "tmin"="min(y) + 0.1", "tmax"="max(y) - 0.1", "n.t"="25", "u"="function(y, t) y - t")
	/**
	 * 
	 * This function calculates the empirical influence values for a
	 * statistic applied to a data set.  It allows four types of calculation,
	 * namely the infinitesimal jackknife (using numerical differentiation),
	 * the usual jackknife estimates, the \sQuote{positive} jackknife
	 * estimates and a method which estimates the empirical influence values
	 * using regression of bootstrap replicates of the statistic.  All
	 * methods can be used with one or more samples.
	 *
	 */
	exported function "empinf"("boot.out"="", "data"="", "statistic"="", "type"="", "stype"="", "index"="1", "t"="", "strata"="rep(1, n)", "eps"="0.001", "...")
	function "empinf.reg"("boot.out", "t"="boot.out$t[, 1L]")
	/**
	 * 
	 *This function calculates overall and pointwise confidence envelopes for a 
	 *curve based on bootstrap replicates of the curve evaluated at a number of
	 *fixed points.
	 *
	 */
	exported function "envelope"("boot.out"="", "mat"="", "level"="0.95", "index"="1L:ncol(mat)")
	/**
	 * 
	 *This function calculates exponentially tilted multinomial distributions 
	 *such that the resampling distributions of the linear approximation to a
	 *statistic have the required means.
	 *
	 */
	exported function "exp.tilt"("L", "theta"="", "t0"="0", "lambda"="", "strata"="rep(1, length(L))")
	function "extra.array"("n", "R", "m", "strata"="rep(1, n)")
	/**
	 * 
	 *Take a matrix of indices for nonparametric bootstrap resamples and
	 *return the frequencies of the original observations in each resample.
	 *
	 */
	exported function "freq.array"("i.array")
	/**
	 * 
	 *Calculates jackknife deviance residuals, standardized deviance residuals, 
	 *standardized Pearson residuals, approximate Cook statistic, leverage and
	 *estimated dispersion.
	 *
	 */
	exported function "glm.diag"("glmfit")
	/**
	 * 
	 *Makes plot of jackknife deviance residuals against linear predictor, 
	 *normal scores plots of standardized deviance residuals, plot of approximate Cook statistics against leverage/(1-leverage), and case plot of Cook statistic.
	 *
	 */
	exported function "glm.diag.plots"("glmfit", "glmdiag"="glm.diag(glmfit)", "subset"="", "iden"="FALSE", "labels"="", "ret"="FALSE")
	function "iden"("n")
	/**
	 * 
	 * Central moment, tail probability, and quantile estimates for a statistic
	 * under importance resampling.
	 *
	 */
	exported function "imp.moments"("boot.out"="", "index"="1", "t"="boot.out$t[, index]", "w"="", "def"="TRUE", "q"="")
	/**
	 * 
	 * Central moment, tail probability, and quantile estimates for a statistic
	 * under importance resampling.
	 *
	 */
	exported function "imp.prob"("boot.out"="", "index"="1", "t0"="boot.out$t0[index]", "t"="boot.out$t[, index]", "w"="", "def"="TRUE", "q"="")
	/**
	 * 
	 * Central moment, tail probability, and quantile estimates for a statistic
	 * under importance resampling.
	 *
	 */
	exported function "imp.quantile"("boot.out"="", "alpha"="", "index"="1", "t"="boot.out$t[, index]", "w"="", "def"="TRUE", "q"="")
	/**
	 * 
	 * Central moment, tail probability, and quantile estimates for a statistic
	 * under importance resampling.
	 *
	 */
	function "imp.reg"("w")
	/**
	 * 
	 *This function calculates the importance sampling weight required to correct
	 *for simulation from a distribution with probabilities \code{p} when estimates 
	 *are required assuming that simulation was from an alternative distribution 
	 *with probabilities \code{q}.
	 *
	 */
	exported function "imp.weights"("boot.out", "def"="TRUE", "q"="")
	function "importance.array"("n", "R", "weights", "strata")
	function "importance.array.bal"("n", "R", "weights", "strata")
	function "index.array"("n", "R", "sim", "strata"="rep(1, n)", "m"="0", "L"="", "weights"="")
	function "inf.jack"("data", "stat", "index"="1", "strata"="rep(1, n)", "eps"="0.001", "...")
	/**
	 * 
	 *Given a numeric object return the inverse logit of the values.
	 *
	 */
	exported function "inv.logit"("x")
	function "isMatrix"("x")
	/**
	 * 
	 *This function calculates the jackknife influence values from a bootstrap
	 *output object and plots the corresponding jackknife-after-bootstrap plot.
	 *
	 */
	exported function "jack.after.boot"("boot.out", "index"="1", "t"="", "L"="", "useJ"="TRUE", "stinf"="TRUE", "alpha"="", "main"="", "ylab"="", "...")
	/**
	 * 
	 *Estimates the skewness of a statistic from its empirical influence values.
	 *
	 */
	exported function "k3.linear"("L", "strata"="")
	/**
	 * 
	 * Functions for use with the practicals in Davison and Hinkley (1997).
	 *
	 */
	exported function "lik.CI"("like", "lim")
	/**
	 * 
	 *This function takes a bootstrap object and for each bootstrap replicate
	 *it calculates the linear approximation to the statistic of interest for 
	 *that bootstrap sample.
	 *
	 */
	exported function "linear.approx"("boot.out", "L"="", "index"="1", "type"="", "t0"="", "t"="", "...")
	/**
	 * 
	 * This function adds a line corresponding to a saddlepoint density or 
	 * distribution function approximation to the current plot.
	 *
	 */
	function "lines.saddle.distn"("x", "dens"="TRUE", "h"="function(u) u", "J"="function(u) 1", "npts"="50", "lty"="1", "...")
	/**
	 * 
	 *This function calculates the logit of proportions.
	 *
	 */
	exported function "logit"("p")
	function "make.ends"("a", "n")
	/**
	 * 
	 * Functions for use with the practicals in Davison and Hinkley (1997).
	 *
	 */
	exported function "nested.corr"("data", "w", "t0", "M")
	/**
	 * 
	 *Using the normal approximation to a statistic, calculate equi-tailed two-sided 
	 *confidence intervals.
	 *
	 */
	exported function "norm.ci"("boot.out"="", "conf"="0.95", "index"="1", "var.t0"="", "t0"="", "t"="", "L"="", "h"="function(t) t", "hdot"="function(t) 1", "hinv"="function(t) t")
	function "norm.inter"("t", "alpha")
	function "normalize"("wts", "strata")
	function "ordinary.array"("n", "R", "strata")
	function "perc.ci"("t", "conf"="0.95", "hinv"="function(t) t")
	function "permutation.array"("n", "R", "strata")
	/**
	 * 
	 *This takes a bootstrap object and produces plots for the bootstrap
	 *replicates of the variable of interest.  
	 *
	 */
	function "plot.boot"("x", "index"="1", "t0"="", "t"="", "jack"="FALSE", "qdist"="norm", "nclass"="", "df", "...")
	function "positive.jack"("data", "stat", "stype"="w", "index"="1", "strata"="rep(1, n)", "...")
	/**
	 * 
	 * This is a method for the function \code{print()} for objects of the
	 * class \code{"boot"}.
	 *
	 */
	function "print.boot"("x", "digits"="getOption(\"digits\")", "index"="1L:ncol(boot.out$t)", "...")
	/**
	 * 
	 *This is a method for the function \code{print()} to print objects of the
	 *class \code{"bootci"}.
	 *
	 */
	function "print.bootci"("x", "hinv"="", "...")
	/**
	 * 
	 *This is a method for the function \code{print()} to print objects of class
	 *\code{"saddle.distn"}.
	 *
	 */
	function "print.saddle.distn"("x", "...")
	/**
	 * 
	 *This is a method for the function \code{print()} to print objects of class
	 *\code{"simplex"}.
	 *
	 */
	function "print.simplex"("x", "...")
	function "rperm"("x")
	/**
	 * 
	 * This function calculates a saddlepoint approximation to the
	 * distribution of a linear combination of \bold{W} at a particular point
	 * \code{u}, where \bold{W} is a vector of random variables.  The
	 * distribution of \bold{W} may be multinomial (default), Poisson or
	 * binary.  Other distributions are possible also if the adjusted
	 * cumulant generating function and its second derivative are given.
	 * Conditional saddlepoint approximations to the distribution of one
	 * linear combination given the values of other linear combinations of
	 * \bold{W} can be calculated for \bold{W} having binary or Poisson
	 * distributions.
	 *
	 */
	exported function "saddle"("A"="", "u"="", "wdist"="m", "type"="simp", "d"="", "d1"="1", "init"="rep(0.1, d)", "mu"="rep(0.5, n)", "LR"="FALSE", "strata"="", "K.adj"="", "K2"="")
	/**
	 * 
	 * Approximate an entire distribution using saddlepoint methods.  This
	 * function can calculate simple and conditional saddlepoint distribution
	 * approximations for a univariate quantity of interest.  For the simple
	 * saddlepoint the quantity of interest is a linear combination of
	 * \bold{W} where \bold{W} is a vector of random variables.  For the
	 * conditional saddlepoint we require the distribution of one linear
	 * combination given the values of any number of other linear
	 * combinations. The distribution of \bold{W} must be one of multinomial,
	 * Poisson or binary.  The primary use of this function is to calculate
	 * quantiles of bootstrap distributions using saddlepoint approximations.
	 * Such quantiles are required by the function \code{\link{control}} to
	 * approximate the distribution of the linear approximation to a
	 * statistic.
	 *
	 */
	exported function "saddle.distn"("A", "u"="", "alpha"="", "wdist"="m", "type"="simp", "npts"="20", "t"="", "t0"="", "init"="rep(0.1, d)", "mu"="rep(0.5, n)", "LR"="FALSE", "strata"="", "...")
	function "sample0"("x", "...")
	function "scramble"("ts", "norm"="TRUE")
	/**
	 * 
	 * This function will optimize the linear function \code{a%*%x} subject
	 * to the constraints \code{A1%*%x <= b1}, \code{A2%*%x >= b2},
	 * \code{A3%*%x = b3} and \code{x >= 0}.  Either maximization or
	 * minimization is possible but the default is minimization.
	 *
	 */
	exported function "simplex"("a", "A1"="", "b1"="", "A2"="", "b2"="", "A3"="", "b3"="", "maxi"="FALSE", "n.iter"="n + 2 * m", "eps"="1e-10")
	function "simplex1"("a", "A", "b", "init", "basic", "val"="0", "stage"="2", "n1", "eps"="1e-10", "n.iter")
	/**
	 * 
	 *This function uses the method of frequency smoothing to find a distribution 
	 *on a data set which has a required value, \code{theta},  of the statistic of 
	 *interest.  The method results in distributions which vary smoothly with 
	 *\code{theta}.
	 *
	 */
	exported function "smooth.f"("theta", "boot.out", "index"="1", "t"="boot.out$t[, index]", "width"="0.5")
	function "stud.ci"("tv0", "tv", "conf"="0.95", "hinv"="function(t) t")
	/**
	 * 
	 * This function will run an initial bootstrap with equal resampling 
	 * probabilities (if required) and will use the output of the initial run to 
	 * find resampling probabilities which put the
	 * value of the statistic at required values.  It then runs an importance
	 * resampling bootstrap using the calculated probabilities as the resampling
	 * distribution.
	 *
	 */
	exported function "tilt.boot"("data", "statistic", "R", "sim"="ordinary", "stype"="i", "strata"="rep(1, n)", "L"="", "theta"="", "alpha"="c(0.025, 0.975)", "tilt"="TRUE", "width"="0.5", "index"="1", "...")
	function "ts.array"("n", "n.sim", "R", "l", "sim", "endcorr")
	/**
	 * 
	 * Generate \code{R} bootstrap replicates of a statistic applied to a
	 * time series.  The replicate time series can be generated using fixed
	 * or random block lengths or can be model based replicates.
	 *
	 */
	function "ts.return"("t0", "t", "R", "tseries", "seed", "stat", "sim", "endcorr", "n.sim", "l", "ran.gen", "ran.args", "call", "norm")
	/**
	 * 
	 * Generate \code{R} bootstrap replicates of a statistic applied to a
	 * time series.  The replicate time series can be generated using fixed
	 * or random block lengths or can be model based replicates.
	 *
	 */
	exported function "tsboot"("tseries", "statistic", "R", "l"="", "sim"="model", "endcorr"="TRUE", "n.sim"="NROW(tseries)", "orig.t"="TRUE", "ran.gen"="function(tser, n.sim, args) tser", "ran.args"="", "norm"="TRUE", "...", "parallel"="c(\"no\", \"multicore\", \"snow\")", "ncpus"="getOption(\"boot.ncpus\", 1L)", "cl"="")
	function "usual.jack"("data", "stat", "stype"="w", "index"="1", "strata"="rep(1, n)", "...")
	/**
	 * 
	 *Estimates the variance of a statistic from its empirical influence values.
	 *
	 */
	exported function "var.linear"("L", "strata"="")
	function "zero"("n", "m")
}
