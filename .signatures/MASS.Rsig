package "MASS" "7.3.45" {
	var ".__NAMESPACE__."
	var ".__S3MethodsTable__."
	function ".Diag"("nms", "sparse")
	var ".noGenerics"
	function ".onUnload"("libpath")
	var ".packageName"
	/**
	 * 
	 *Find rational approximations to the components of a real numeric
	 *object using a standard continued fraction method.
	 *
	 */
	function ".rat"("x", "cycles"="10", "max.denominator"="2000")
	/**
	 * 
	 *Find rational approximations to the components of a real numeric
	 *object using a standard continued fraction method.
	 *
	 */
	function "[.fractions"("x", "...")
	/**
	 * 
	 *Find rational approximations to the components of a real numeric
	 *object using a standard continued fraction method.
	 *
	 */
	function "[<-.fractions"("x", "...", "value")
	/**
	 * 
	 *Try fitting all models that differ from the current model by adding a
	 *single term from those supplied, maintaining marginality.
	 *
	 *
	 *This function is generic; there exist methods for classes \code{lm} and
	 *\code{glm} and the default method will work for many other classes.
	 *
	 */
	exported function "addterm"("object", "...")
	/**
	 * 
	 *Try fitting all models that differ from the current model by adding a
	 *single term from those supplied, maintaining marginality.
	 *
	 *
	 *This function is generic; there exist methods for classes \code{lm} and
	 *\code{glm} and the default method will work for many other classes.
	 *
	 */
	function "addterm.default"("object", "scope", "scale"="0", "test"="c(\"none\", \"Chisq\")", "k"="2", "sorted"="FALSE", "trace"="FALSE", "...")
	/**
	 * 
	 *Try fitting all models that differ from the current model by adding a
	 *single term from those supplied, maintaining marginality.
	 *
	 *
	 *This function is generic; there exist methods for classes \code{lm} and
	 *\code{glm} and the default method will work for many other classes.
	 *
	 */
	function "addterm.glm"("object", "scope", "scale"="0", "test"="c(\"none\", \"Chisq\", \"F\")", "k"="2", "sorted"="FALSE", "trace"="FALSE", "...")
	/**
	 * 
	 *Try fitting all models that differ from the current model by adding a
	 *single term from those supplied, maintaining marginality.
	 *
	 *
	 *This function is generic; there exist methods for classes \code{lm} and
	 *\code{glm} and the default method will work for many other classes.
	 *
	 */
	function "addterm.lm"("object", "scope", "scale"="0", "test"="c(\"none\", \"Chisq\", \"F\")", "k"="2", "sorted"="FALSE", "...")
	function "addterm.mlm"("object", "...")
	function "addterm.negbin"("object", "...")
	function "addterm.survreg"("object", "...")
	function "anova.glmmPQL"("object", "...")
	function "anova.loglm"("object", "...", "test"="c(\"Chisq\", \"chisq\", \"LR\")")
	/**
	 * 
	 *Method function to perform sequential likelihood ratio tests for Negative
	 *Binomial generalized linear models.
	 *
	 */
	function "anova.negbin"("object", "...", "test"="Chisq")
	function "anova.polr"("object", "...", "test"="c(\"Chisq\", \"none\")")
	/**
	 * 
	 *Integrate a function of one variable over a finite range using a
	 *recursive adaptive method.  This function is mainly for
	 *demonstration purposes.
	 *
	 */
	exported function "area"("f", "a", "b", "...", "fa"="f(a, ...)", "fb"="f(b, ...)", "limit"="10", "eps"="1e-05")
	/**
	 * 
	 *Find rational approximations to the components of a real numeric
	 *object using a standard continued fraction method.
	 *
	 */
	function "as.character.fractions"("x", "...")
	/**
	 * 
	 *Find rational approximations to the components of a real numeric
	 *object using a standard continued fraction method.
	 *
	 */
	exported function "as.fractions"("x")
	/**
	 * 
	 *A well-supported rule-of-thumb for choosing the bandwidth of a Gaussian
	 *kernel density estimator.
	 *
	 */
	exported function "bandwidth.nrd"("x")
	/**
	 * 
	 *Uses biased cross-validation to select the bandwidth of a  Gaussian
	 *kernel density estimator.
	 *
	 */
	exported function "bcv"("x", "nb"="1000", "lower"="0.1 * hmax", "upper")
	function "biplot.bdr"("obs", "bivars", "col", "cex"="rep(par(\"cex\"), 2L)", "olab"="", "vlab"="", "xlim"="", "ylim"="", "...")
	function "biplot.correspondence"("x", "type"="c(\"symmetric\", \"rows\", \"columns\")", "...")
	/**
	 * 
	 * Computes and optionally plots profile log-likelihoods for the
	 * parameter of the Box-Cox power transformation.
	 *
	 */
	exported function "boxcox"("object", "...")
	/**
	 * 
	 * Computes and optionally plots profile log-likelihoods for the
	 * parameter of the Box-Cox power transformation.
	 *
	 */
	function "boxcox.default"("object", "lambda"="seq(-2, 2, 1/10)", "plotit"="TRUE", "interp"="(plotit && (m < 100))", "eps"="1/50", "xlab"="expression(lambda)", "ylab"="log-Likelihood", "...")
	/**
	 * 
	 * Computes and optionally plots profile log-likelihoods for the
	 * parameter of the Box-Cox power transformation.
	 *
	 */
	function "boxcox.formula"("object", "lambda"="seq(-2, 2, 1/10)", "plotit"="TRUE", "interp"="(plotit && (m < 100))", "eps"="1/50", "xlab"="expression(lambda)", "ylab"="log-Likelihood", "...")
	/**
	 * 
	 * Computes and optionally plots profile log-likelihoods for the
	 * parameter of the Box-Cox power transformation.
	 *
	 */
	function "boxcox.lm"("object", "lambda"="seq(-2, 2, 1/10)", "plotit"="TRUE", "interp"="(plotit && (m < 100))", "eps"="1/50", "xlab"="expression(lambda)", "ylab"="log-Likelihood", "...")
	function "coef.fitdistr"("object", "...")
	/**
	 * 
	 *Linear discriminant analysis.
	 *
	 */
	function "coef.lda"("object", "...")
	function "coef.loglm"("object", "...")
	function "coef.ridgelm"("object", "...")
	/**
	 * 
	 * Convert lists to data frames for use by lattice.
	 *
	 */
	exported function "con2tr"("obj")
	/**
	 * 
	 * Computes confidence intervals for one or more parameters in a fitted
	 * model.  Package \pkg{MASS} adds methods for \code{glm} and \code{nls} fits.
	 *
	 */
	function "confint.glm"("object", "parm", "level"="0.95", "trace"="FALSE", "...")
	/**
	 * 
	 * Computes confidence intervals for one or more parameters in a fitted
	 * model.  Package \pkg{MASS} adds methods for \code{glm} and \code{nls} fits.
	 *
	 */
	function "confint.nls"("object", "parm", "level"="0.95", "...")
	function "confint.polr"("object", "parm", "level"="0.95", "trace"="FALSE", "...")
	/**
	 * 
	 * Computes confidence intervals for one or more parameters in a fitted
	 * model.  Package \pkg{MASS} adds methods for \code{glm} and \code{nls} fits.
	 *
	 */
	function "confint.profile.glm"("object", "parm"="seq_along(pnames)", "level"="0.95", "...")
	/**
	 * 
	 * Computes confidence intervals for one or more parameters in a fitted
	 * model.  Package \pkg{MASS} adds methods for \code{glm} and \code{nls} fits.
	 *
	 */
	function "confint.profile.nls"("object", "parm"="seq_along(pnames)", "level"="0.95", "...")
	function "confint.profile.polr"("object", "parm"="seq_along(pnames)", "level"="0.95", "...")
	/**
	 * 
	 * A coding for factors based on successive differences.
	 *
	 */
	exported function "contr.sdif"("n", "contrasts"="TRUE", "sparse"="FALSE")
	/**
	 * 
	 *Find the principal canonical correlation and corresponding row- and
	 *column-scores from a correspondence analysis of a two-way contingency
	 *table.
	 *
	 */
	exported function "corresp"("x", "...")
	/**
	 * 
	 *Find the principal canonical correlation and corresponding row- and
	 *column-scores from a correspondence analysis of a two-way contingency
	 *table.
	 *
	 */
	function "corresp.data.frame"("x", "...")
	/**
	 * 
	 *Find the principal canonical correlation and corresponding row- and
	 *column-scores from a correspondence analysis of a two-way contingency
	 *table.
	 *
	 */
	function "corresp.default"("x", "...")
	/**
	 * 
	 *Find the principal canonical correlation and corresponding row- and
	 *column-scores from a correspondence analysis of a two-way contingency
	 *table.
	 *
	 */
	function "corresp.factor"("x", "y", "...")
	/**
	 * 
	 *Find the principal canonical correlation and corresponding row- and
	 *column-scores from a correspondence analysis of a two-way contingency
	 *table.
	 *
	 */
	function "corresp.formula"("formula", "data"="parent.frame()", "...")
	/**
	 * 
	 *Find the principal canonical correlation and corresponding row- and
	 *column-scores from a correspondence analysis of a two-way contingency
	 *table.
	 *
	 */
	function "corresp.matrix"("x", "nf"="1", "...")
	/**
	 * 
	 *Find the principal canonical correlation and corresponding row- and
	 *column-scores from a correspondence analysis of a two-way contingency
	 *table.
	 *
	 */
	function "corresp.xtabs"("x", "...")
	/**
	 * 
	 * Compute a multivariate location and scale estimate with a high
	 * breakdown point -- this can be thought of as estimating the mean and
	 * covariance of the \code{good} part of the data. \code{cov.mve} and
	 * \code{cov.mcd} are compatibility wrappers.
	 *
	 */
	exported function "cov.mcd"("...")
	/**
	 * 
	 * Compute a multivariate location and scale estimate with a high
	 * breakdown point -- this can be thought of as estimating the mean and
	 * covariance of the \code{good} part of the data. \code{cov.mve} and
	 * \code{cov.mcd} are compatibility wrappers.
	 *
	 */
	exported function "cov.mve"("...")
	/**
	 * 
	 * Compute a multivariate location and scale estimate with a high
	 * breakdown point -- this can be thought of as estimating the mean and
	 * covariance of the \code{good} part of the data. \code{cov.mve} and
	 * \code{cov.mcd} are compatibility wrappers.
	 *
	 */
	exported function "cov.rob"("x", "cor"="FALSE", "quantile.used"="floor((n + p + 1)/2)", "method"="c(\"mve\", \"mcd\", \"classical\")", "nsamp"="best", "seed")
	/**
	 * 
	 *Estimates a covariance or correlation matrix assuming the data came
	 *from a multivariate t distribution: this provides some degree of
	 *robustness to outlier without giving a high breakdown point.
	 *
	 */
	exported function "cov.trob"("x", "wt"="rep(1, n)", "cor"="FALSE", "center"="TRUE", "nu"="5", "maxit"="25", "tol"="0.01")
	/**
	 * 
	 *\code{\link{loglm}} allows dimension numbers to be used in place of names in
	 *the formula.  \code{denumerate} modifies such a formula into one that
	 *\code{\link{terms}} can process.
	 *
	 */
	exported function "denumerate"("x")
	/**
	 * 
	 *\code{\link{loglm}} allows dimension numbers to be used in place of names in
	 *the formula.  \code{denumerate} modifies such a formula into one that
	 *\code{\link{terms}} can process.
	 *
	 */
	function "denumerate.formula"("x")
	function "dgumbel"("x", "loc"="0", "scale"="1", "log"="FALSE")
	function "dGumbel"("x", "loc"="0", "scale"="1", "log"="FALSE")
	/**
	 * 
	 *Calibrate binomial assays, generalizing the calculation of LD50.
	 *
	 */
	exported function "dose.p"("obj", "cf"="1:2", "p"="0.5")
	/**
	 * 
	 *Try fitting all models that differ from the current model by dropping a
	 *single term, maintaining marginality.
	 *
	 *
	 *This function is generic; there exist methods for classes \code{lm} and
	 *\code{glm} and the default method will work for many other classes.
	 *
	 */
	exported function "dropterm"("object", "...")
	/**
	 * 
	 *Try fitting all models that differ from the current model by dropping a
	 *single term, maintaining marginality.
	 *
	 *
	 *This function is generic; there exist methods for classes \code{lm} and
	 *\code{glm} and the default method will work for many other classes.
	 *
	 */
	function "dropterm.default"("object", "scope", "scale"="0", "test"="c(\"none\", \"Chisq\")", "k"="2", "sorted"="FALSE", "trace"="FALSE", "...")
	/**
	 * 
	 *Try fitting all models that differ from the current model by dropping a
	 *single term, maintaining marginality.
	 *
	 *
	 *This function is generic; there exist methods for classes \code{lm} and
	 *\code{glm} and the default method will work for many other classes.
	 *
	 */
	function "dropterm.glm"("object", "scope", "scale"="0", "test"="c(\"none\", \"Chisq\", \"F\")", "k"="2", "sorted"="FALSE", "trace"="FALSE", "...")
	/**
	 * 
	 *Try fitting all models that differ from the current model by dropping a
	 *single term, maintaining marginality.
	 *
	 *
	 *This function is generic; there exist methods for classes \code{lm} and
	 *\code{glm} and the default method will work for many other classes.
	 *
	 */
	function "dropterm.lm"("object", "scope"="drop.scope(object)", "scale"="0", "test"="c(\"none\", \"Chisq\", \"F\")", "k"="2", "sorted"="FALSE", "...")
	function "dropterm.mlm"("object", "...")
	function "dropterm.negbin"("object", "...")
	function "dropterm.survreg"("object", "...")
	/**
	 * 
	 *Internal MASS functions.
	 *
	 */
	exported function "enlist"("vec")
	/**
	 * 
	 *Version of a scatterplot with scales chosen to be equal on both axes, that
	 *is 1cm represents the same units on each
	 *
	 */
	exported function "eqscplot"("x", "y", "ratio"="1", "tol"="0.04", "uin", "...")
	/**
	 * 
	 * Performs stepwise model selection by AIC.
	 *
	 */
	function "extractAIC.gls"("fit", "scale", "k"="2", "...")
	/**
	 * 
	 * Performs stepwise model selection by AIC.
	 *
	 */
	function "extractAIC.lme"("fit", "scale", "k"="2", "...")
	function "extractAIC.loglm"("fit", "scale", "k"="2", "...")
	function "extractAIC.polr"("fit", "scale"="0", "k"="2", "...")
	/**
	 * 
	 * A modification of the system function \code{\link{glm}()} to include
	 * estimation of the additional parameter, \code{theta}, for a
	 * Negative Binomial generalized linear model.
	 *
	 */
	function "family.negbin"("object", "...")
	/**
	 * 
	 *Internal MASS functions.
	 *
	 */
	exported function "fbeta"("x", "alpha", "beta")
	/**
	 * 
	 * Maximum-likelihood fitting of univariate distributions, allowing
	 * parameters to be held fixed if desired.
	 *
	 */
	exported function "fitdistr"("x", "densfun", "start", "...")
	function "fitted.loglm"("object", "...")
	/**
	 * 
	 *Find rational approximations to the components of a real numeric
	 *object using a standard continued fraction method.
	 *
	 */
	exported function "fractions"("x", "cycles"="10", "max.denominator"="2000", "...")
	/**
	 * 
	 *Internal MASS functions.
	 *
	 */
	exported function "frequency.polygon"("x", "nclass"="nclass.freq(x)", "xlab"="", "ylab"="", "...")
	/**
	 * 
	 *A front end to \code{gamma.shape} for convenience.  Finds the
	 *reciprocal of the estimate of the shape parameter only.
	 *
	 */
	exported function "gamma.dispersion"("object", "...")
	/**
	 * 
	 *Find the maximum likelihood estimate of the shape parameter of
	 *the gamma distribution after fitting a \code{Gamma} generalized
	 *linear model.
	 *
	 */
	exported function "gamma.shape"("object", "...")
	/**
	 * 
	 *Find the maximum likelihood estimate of the shape parameter of
	 *the gamma distribution after fitting a \code{Gamma} generalized
	 *linear model.
	 *
	 */
	function "gamma.shape.glm"("object", "it.lim"="10", "eps.max"=".Machine$double.eps^0.25", "verbose"="FALSE", "...")
	/**
	 * 
	 *Calculates the Moore-Penrose generalized inverse of a matrix
	 *\code{X}.
	 *
	 */
	exported function "ginv"("X", "tol"="sqrt(.Machine$double.eps)")
	/**
	 * 
	 *This function modifies an output object from \code{glm.nb()} to one
	 *that looks like the output from \code{glm()} with a negative binomial
	 *family.  This allows it to be updated keeping the theta parameter
	 *fixed.
	 *
	 */
	exported function "glm.convert"("object")
	/**
	 * 
	 * A modification of the system function \code{\link{glm}()} to include
	 * estimation of the additional parameter, \code{theta}, for a
	 * Negative Binomial generalized linear model.
	 *
	 */
	exported function "glm.nb"("formula", "data", "weights", "subset", "na.action", "start"="", "etastart", "mustart", "control"="glm.control(...)", "method"="glm.fit", "model"="TRUE", "x"="FALSE", "y"="TRUE", "contrasts"="", "...", "init.theta", "link")
	/**
	 * 
	 *Fit a GLMM model with multivariate normal random effects, using
	 *Penalized Quasi-Likelihood.
	 *
	 */
	exported function "glmmPQL"("fixed", "random", "family", "data", "correlation", "weights", "control", "niter"="10", "verbose"="TRUE", "...")
	/**
	 * 
	 * Plot a histogram with automatic bin width selection, using the Scott
	 * or Freedman--Diaconis formulae.
	 *
	 */
	exported function "hist.FD"("x", "prob"="TRUE", "xlab"="deparse(substitute(x))", "...")
	/**
	 * 
	 * Plot a histogram with automatic bin width selection, using the Scott
	 * or Freedman--Diaconis formulae.
	 *
	 */
	exported function "hist.scott"("x", "prob"="TRUE", "xlab"="deparse(substitute(x))", "...")
	/**
	 * 
	 *Finds the Huber M-estimator of location with MAD scale.
	 *
	 */
	exported function "huber"("y", "k"="1.5", "tol"="1e-06")
	/**
	 * 
	 *Finds the Huber M-estimator for location with scale specified, scale
	 *with location specified, or both if neither is specified.
	 *
	 */
	exported function "hubers"("y", "k"="1.5", "mu", "s", "initmu"="median(y)", "tol"="1e-06")
	/**
	 * 
	 *Find rational approximations to the components of a real numeric
	 *object using a standard continued fraction method.
	 *
	 */
	exported function "is.fractions"("f")
	/**
	 * 
	 *One form of non-metric multidimensional scaling
	 *
	 */
	exported function "isoMDS"("d", "y"="cmdscale(d, k)", "k"="2", "maxit"="50", "trace"="TRUE", "tol"="0.001", "p"="2")
	/**
	 * 
	 *Two-dimensional kernel density estimation with an axis-aligned
	 *bivariate normal kernel, evaluated on a square grid.
	 *
	 */
	exported function "kde2d"("x", "y", "h", "n"="25", "lims"="c(range(x), range(y))")
	/**
	 * 
	 *Linear discriminant analysis.
	 *
	 */
	exported function "lda"("x", "...")
	/**
	 * 
	 *Linear discriminant analysis.
	 *
	 */
	function "lda.data.frame"("x", "...")
	/**
	 * 
	 *Linear discriminant analysis.
	 *
	 */
	function "lda.default"("x", "grouping", "prior", "tol"="1e-04", "method"="c(\"moment\", \"mle\", \"mve\", \"t\")", "CV"="FALSE", "nu"="5", "...")
	/**
	 * 
	 *Linear discriminant analysis.
	 *
	 */
	function "lda.formula"("formula", "data", "...", "subset", "na.action")
	/**
	 * 
	 *Linear discriminant analysis.
	 *
	 */
	function "lda.matrix"("x", "grouping", "...", "subset", "na.action")
	/**
	 * 
	 *Plot histograms or density plots of data on a single Fisher linear
	 *discriminant.
	 *
	 */
	exported function "ldahist"("data", "g", "nbins"="25", "h", "x0"="-h/1000", "breaks", "xlim"="range(breaks)", "ymax"="0", "width", "type"="c(\"histogram\", \"density\", \"both\")", "sep"="(type != \"density\")", "col"="5", "xlab"="deparse(substitute(data))", "bty"="n", "...")
	/**
	 * 
	 *Fit linear models by Generalized Least Squares
	 *
	 */
	exported function "lm.gls"("formula", "data", "W", "subset", "na.action", "inverse"="FALSE", "method"="qr", "model"="FALSE", "x"="FALSE", "y"="FALSE", "contrasts"="", "...")
	/**
	 * 
	 *Fit a linear model by ridge regression.
	 *
	 */
	exported function "lm.ridge"("formula", "data", "subset", "na.action", "lambda"="0", "model"="FALSE", "x"="FALSE", "y"="FALSE", "contrasts"="", "...")
	/**
	 * 
	 * Fit a regression to the \emph{good} points in the dataset, thereby
	 * achieving a regression estimator with a high breakdown point.
	 * \code{lmsreg} and \code{ltsreg} are compatibility wrappers.
	 *
	 */
	exported function "lmsreg"("...")
	/**
	 * 
	 *The standardized residuals.  These are normalized to unit
	 *variance, fitted including the current data point.
	 *
	 */
	exported function "lmwork"("object")
	function "logLik.fitdistr"("object", "REML"="FALSE", "...")
	function "logLik.glmmPQL"("object", "...")
	/**
	 * 
	 * A modification of the system function \code{\link{glm}()} to include
	 * estimation of the additional parameter, \code{theta}, for a
	 * Negative Binomial generalized linear model.
	 *
	 */
	function "logLik.negbin"("object", "...")
	function "logLik.polr"("object", "...")
	/**
	 * 
	 *This function provides a front-end to the standard function,
	 *\code{loglin}, to allow log-linear models to be specified and fitted
	 *in a manner similar to that of other fitting functions, such as
	 *\code{glm}.
	 *
	 */
	exported function "loglm"("formula", "data", "subset", "na.action", "...")
	/**
	 * 
	 * \code{loglm1} is an internal function used by \code{\link{loglm}}.
	 * It is a generic function dispatching on the \code{data} argument.
	 *
	 */
	exported function "loglm1"("formula", "data", "...")
	/**
	 * 
	 * \code{loglm1} is an internal function used by \code{\link{loglm}}.
	 * It is a generic function dispatching on the \code{data} argument.
	 *
	 */
	function "loglm1.data.frame"("formula", "data", "...")
	/**
	 * 
	 * \code{loglm1} is an internal function used by \code{\link{loglm}}.
	 * It is a generic function dispatching on the \code{data} argument.
	 *
	 */
	function "loglm1.default"("formula", "data", "start"="rep(1, length(data))", "fitted"="FALSE", "keep.frequencies", "param"="TRUE", "eps"="1/10", "iter"="40", "print"="FALSE", "...")
	/**
	 * 
	 * \code{loglm1} is an internal function used by \code{\link{loglm}}.
	 * It is a generic function dispatching on the \code{data} argument.
	 *
	 */
	function "loglm1.xtabs"("formula", "data", "...")
	/**
	 * 
	 *Find and optionally plot the marginal (profile) likelihood for alpha
	 *for a transformation model of the form \code{log(y + alpha) ~ x1 + x2 + \dots{}}.
	 *
	 */
	exported function "logtrans"("object", "...")
	/**
	 * 
	 *Find and optionally plot the marginal (profile) likelihood for alpha
	 *for a transformation model of the form \code{log(y + alpha) ~ x1 + x2 + \dots{}}.
	 *
	 */
	function "logtrans.default"("object", "...", "alpha"="seq(0.5, 6, by = 0.25) - min(y)", "plotit"="TRUE", "interp"="(plotit && (m < 100))", "xlab"="alpha", "ylab"="log Likelihood")
	/**
	 * 
	 *Find and optionally plot the marginal (profile) likelihood for alpha
	 *for a transformation model of the form \code{log(y + alpha) ~ x1 + x2 + \dots{}}.
	 *
	 */
	function "logtrans.formula"("object", "data", "...")
	/**
	 * 
	 *Find and optionally plot the marginal (profile) likelihood for alpha
	 *for a transformation model of the form \code{log(y + alpha) ~ x1 + x2 + \dots{}}.
	 *
	 */
	function "logtrans.lm"("object", "...")
	/**
	 * 
	 * Fit a regression to the \emph{good} points in the dataset, thereby
	 * achieving a regression estimator with a high breakdown point.
	 * \code{lmsreg} and \code{ltsreg} are compatibility wrappers.
	 *
	 */
	exported function "lqs"("x", "...")
	var "lqs_fitlots"
	/**
	 * 
	 * Fit a regression to the \emph{good} points in the dataset, thereby
	 * achieving a regression estimator with a high breakdown point.
	 * \code{lmsreg} and \code{ltsreg} are compatibility wrappers.
	 *
	 */
	function "lqs.default"("x", "y", "intercept"="TRUE", "method"="c(\"lts\", \"lqs\", \"lms\", \"S\")", "quantile", "control"="lqs.control(...)", "k0"="1.548", "seed", "...")
	/**
	 * 
	 * Fit a regression to the \emph{good} points in the dataset, thereby
	 * achieving a regression estimator with a high breakdown point.
	 * \code{lmsreg} and \code{ltsreg} are compatibility wrappers.
	 *
	 */
	exported function "lqs.formula"("formula", "data", "...", "method"="c(\"lts\", \"lqs\", \"lms\", \"S\", \"model.frame\")", "subset", "na.action", "model"="TRUE", "x.ret"="FALSE", "y.ret"="FALSE", "contrasts"="")
	/**
	 * 
	 * Fit a regression to the \emph{good} points in the dataset, thereby
	 * achieving a regression estimator with a high breakdown point.
	 * \code{lmsreg} and \code{ltsreg} are compatibility wrappers.
	 *
	 */
	exported function "ltsreg"("...")
	/**
	 * 
	 *Find rational approximations to the components of a real numeric
	 *object using a standard continued fraction method.
	 *
	 */
	function "Math.fractions"("x", "...")
	/**
	 * 
	 *Computes a multiple correspondence analysis of a set of factors.
	 *
	 */
	exported function "mca"("df", "nf"="2", "abbrev"="FALSE")
	/**
	 * 
	 *Linear discriminant analysis.
	 *
	 */
	function "model.frame.lda"("formula", "...")
	function "model.frame.polr"("formula", "...")
	/**
	 * 
	 *Quadratic discriminant analysis.
	 *
	 */
	function "model.frame.qda"("formula", "...")
	var "mve_fitlots"
	/**
	 * 
	 * Produces one or more samples from the specified
	 * multivariate normal distribution.
	 *
	 */
	exported function "mvrnorm"("n"="1", "mu", "Sigma", "tol"="1e-06", "empirical"="FALSE", "EISPACK"="FALSE")
	/**
	 * 
	 *Internal MASS functions.
	 *
	 */
	exported function "nclass.freq"("x")
	/**
	 * 
	 *Internal MASS functions.
	 *
	 */
	exported function "neg.bin"("theta"="stop(\"'theta' must be given\")")
	/**
	 * 
	 * Specifies the information required to fit a Negative Binomial generalized
	 * linear model, with known \code{theta} parameter, using \code{glm()}.
	 *
	 */
	exported function "negative.binomial"("theta"="stop(\"'theta' must be specified\")", "link"="log")
	/**
	 * 
	 *Internal MASS functions.
	 *
	 */
	exported function "negexp.SSival"("mCall", "data", "LHS")
	function "nobs.loglm"("object", "...")
	function "nobs.polr"("object", "...")
	/**
	 * 
	 * Given a matrix, \code{M}, find a matrix \code{N} giving a basis for the
	 * (left) null space.  That is \code{crossprod(N, M) = t(N) %*% M}
	 * is an all-zero matrix and \code{N} has the maximum number of linearly
	 * independent columns.
	 *
	 */
	exported function "Null"("M")
	/**
	 * 
	 *Find rational approximations to the components of a real numeric
	 *object using a standard continued fraction method.
	 *
	 */
	function "Ops.fractions"("e1", "e2")
	/**
	 * 
	 *Pairwise scatterplot of the data on the linear discriminants.
	 *
	 */
	function "pairs.lda"("x", "labels"="colnames(x)", "panel", "dimen", "abbrev"="FALSE", "...", "cex"="0.7", "type"="c(\"std\", \"trellis\")")
	/**
	 * 
	 * \code{\link{plot}} and \code{\link{pairs}} methods for objects of
	 * class \code{"profile"}.
	 *
	 */
	function "pairs.profile"("x", "colours"="2:3", "...")
	/**
	 * 
	 *Parallel coordinates plot
	 *
	 */
	exported function "parcoord"("x", "col"="1", "lty"="1", "var.label"="FALSE", "...")
	function "pgumbel"("q", "loc"="0", "scale"="1", "lower.tail"="TRUE")
	function "pGumbel"("q", "loc"="0", "scale"="1", "lower.tail"="TRUE")
	function "plot.correspondence"("x", "scale"="1", "...")
	/**
	 * 
	 *Plots a set of data on one, two or more linear discriminants.
	 *
	 */
	function "plot.lda"("x", "panel", "...", "cex"="0.7", "dimen", "abbrev"="FALSE", "xlab"="LD1", "ylab"="LD2")
	/**
	 * 
	 *Plot a multiple correspondence analysis.
	 *
	 */
	function "plot.mca"("x", "rows"="TRUE", "col", "cex"="par(\"cex\")", "...")
	/**
	 * 
	 * \code{\link{plot}} and \code{\link{pairs}} methods for objects of
	 * class \code{"profile"}.
	 *
	 */
	function "plot.profile"("x", "...")
	/**
	 * 
	 *Fit a linear model by ridge regression.
	 *
	 */
	function "plot.ridgelm"("x", "...")
	/**
	 * 
	 * Fits a logistic or probit regression model to an ordered factor
	 * response.  The default logistic case is \emph{proportional odds
	 *   logistic regression}, after which the function is named.
	 *
	 */
	exported function "polr"("formula", "data", "weights", "start", "...", "subset", "na.action", "contrasts"="", "Hess"="FALSE", "model"="TRUE", "method"="c(\"logistic\", \"probit\", \"loglog\", \"cloglog\", \"cauchit\")")
	function "polr.fit"("x", "y", "wt", "start", "offset", "method", "...")
	/**
	 * 
	 * Obtains predictions from a fitted generalized linear model
	 * with random effects.
	 *
	 */
	function "predict.glmmPQL"("object", "newdata"="", "type"="c(\"link\", \"response\")", "level", "na.action", "...")
	/**
	 * 
	 *Classify multivariate observations in conjunction with \code{lda}, and also
	 *project data onto the linear discriminants.
	 *
	 */
	function "predict.lda"("object", "newdata", "prior"="object$prior", "dimen", "method"="c(\"plug-in\", \"predictive\", \"debiased\")", "...")
	/**
	 * 
	 * Predict from an resistant regression fitted by \code{lqs}.
	 *
	 */
	function "predict.lqs"("object", "newdata", "na.action", "...")
	/**
	 * 
	 *Used to compute coordinates for additional rows or additional factors
	 *in a multiple correspondence analysis.
	 *
	 */
	function "predict.mca"("object", "newdata", "type"="c(\"row\", \"factor\")", "...")
	function "predict.polr"("object", "newdata", "type"="c(\"class\", \"probs\")", "...")
	/**
	 * 
	 *Classify multivariate observations in conjunction with \code{qda}
	 *
	 */
	function "predict.qda"("object", "newdata", "prior"="object$prior", "method"="c(\"plug-in\", \"predictive\", \"debiased\", \"looCV\")", "...")
	/**
	 * 
	 * Fit a linear model by robust regression using an M estimator.
	 *
	 */
	function "predict.rlm"("object", "newdata"="", "scale"="", "...")
	function "print.abbrev"("x", "...")
	function "print.Anova"("x", "...")
	function "print.anova.loglm"("x", "...")
	function "print.correspondence"("x", "...")
	function "print.fitdistr"("x", "digits"="getOption(\"digits\")", "...")
	/**
	 * 
	 *Find rational approximations to the components of a real numeric
	 *object using a standard continued fraction method.
	 *
	 */
	function "print.fractions"("x", "...")
	/**
	 * 
	 *Find the maximum likelihood estimate of the shape parameter of
	 *the gamma distribution after fitting a \code{Gamma} generalized
	 *linear model.
	 *
	 */
	function "print.gamma.shape"("x", "...")
	/**
	 * 
	 *Calibrate binomial assays, generalizing the calculation of LD50.
	 *
	 */
	function "print.glm.dose"("x", "...")
	/**
	 * 
	 *Linear discriminant analysis.
	 *
	 */
	function "print.lda"("x", "...")
	function "print.loglm"("x", "...")
	function "print.lqs"("x", "digits"="max(3, getOption(\"digits\") - 3)", "...")
	/**
	 * 
	 *Computes a multiple correspondence analysis of a set of factors.
	 *
	 */
	function "print.mca"("x", "...")
	function "print.polr"("x", "...")
	/**
	 * 
	 *Quadratic discriminant analysis.
	 *
	 */
	function "print.qda"("x", "...")
	/**
	 * 
	 *Fit a linear model by ridge regression.
	 *
	 */
	function "print.ridgelm"("x", "...")
	/**
	 * 
	 * Fit a linear model by robust regression using an M estimator.
	 *
	 */
	function "print.rlm"("x", "...")
	/**
	 * 
	 *Calculates the root mean square parameter effects and intrinsic relative
	 *curvatures, \eqn{{c^\theta}{c^theta}} and \eqn{{c^\iota}{c^iota}}, for a
	 *fitted nonlinear regression, as defined in Bates & Watts, section 7.3,
	 *p. 253ff
	 *
	 */
	function "print.rms.curv"("x", "...")
	/**
	 * 
	 *Returns a summary list for log-linear models fitted by
	 *iterative proportional scaling using \code{loglm}.
	 *
	 */
	function "print.summary.loglm"("x", "...")
	/**
	 * 
	 *Identical to \code{summary.glm}, but with three lines of additional output: the
	 *ML estimate of theta, its standard error, and twice the log-likelihood
	 *function.
	 *
	 */
	function "print.summary.negbin"("x", "...")
	function "print.summary.polr"("x", "digits"="x$digits", "...")
	/**
	 * 
	 *\code{summary} method for objects of class \code{"rlm"}
	 *
	 */
	function "print.summary.rlm"("x", "digits"="max(3, .Options$digits - 3)", "...")
	/**
	 * 
	 * Investigates the profile log-likelihood function for a fitted model of
	 * class \code{"glm"}.
	 *
	 */
	function "profile.glm"("fitted", "which"="1:p", "alpha"="0.01", "maxsteps"="10", "del"="zmax/5", "trace"="FALSE", "...")
	function "profile.polr"("fitted", "which"="1L:p", "alpha"="0.01", "maxsteps"="10", "del"="zmax/5", "trace"="FALSE", "...")
	/**
	 * 
	 * Fit a linear model by robust regression using an M estimator.
	 *
	 */
	exported function "psi.bisquare"("u", "c"="4.685", "deriv"="0")
	/**
	 * 
	 * Fit a linear model by robust regression using an M estimator.
	 *
	 */
	exported function "psi.hampel"("u", "a"="2", "b"="4", "c"="8", "deriv"="0")
	/**
	 * 
	 * Fit a linear model by robust regression using an M estimator.
	 *
	 */
	exported function "psi.huber"("u", "k"="1.345", "deriv"="0")
	/**
	 * 
	 *Quadratic discriminant analysis.
	 *
	 */
	exported function "qda"("x", "...")
	/**
	 * 
	 *Quadratic discriminant analysis.
	 *
	 */
	function "qda.data.frame"("x", "...")
	/**
	 * 
	 *Quadratic discriminant analysis.
	 *
	 */
	function "qda.default"("x", "grouping", "prior", "method"="c(\"moment\", \"mle\", \"mve\", \"t\")", "CV"="FALSE", "nu"="5", "...")
	/**
	 * 
	 *Quadratic discriminant analysis.
	 *
	 */
	function "qda.formula"("formula", "data", "...", "subset", "na.action")
	/**
	 * 
	 *Quadratic discriminant analysis.
	 *
	 */
	function "qda.matrix"("x", "grouping", "...", "subset", "na.action")
	/**
	 * 
	 *Find rational approximations to the components of a real numeric
	 *object using a standard continued fraction method.
	 *
	 */
	exported function "rational"("x", "cycles"="10", "max.denominator"="2000", "...")
	/**
	 * 
	 *\code{\link{denumerate}} converts a formula written using the conventions of
	 *\code{\link{loglm}} into one that \code{\link{terms}} is able to process.  \code{renumerate}
	 *converts it back again to a form like the original.
	 *
	 */
	exported function "renumerate"("x")
	/**
	 * 
	 *\code{\link{denumerate}} converts a formula written using the conventions of
	 *\code{\link{loglm}} into one that \code{\link{terms}} is able to process.  \code{renumerate}
	 *converts it back again to a form like the original.
	 *
	 */
	function "renumerate.formula"("x")
	function "residuals.loglm"("object", "type"="c(\"deviance\", \"pearson\", \"response\")", "...")
	/**
	 * 
	 * Fit a linear model by robust regression using an M estimator.
	 *
	 */
	exported function "rlm"("x", "...")
	/**
	 * 
	 * Fit a linear model by robust regression using an M estimator.
	 *
	 */
	function "rlm.default"("x", "y", "weights", "...", "w"="rep(1, nrow(x))", "init"="ls", "psi", "scale.est"="c(\"MAD\", \"Huber\", \"proposal 2\")", "k2"="1.345", "method"="c(\"M\", \"MM\")", "wt.method"="c(\"inv.var\", \"case\")", "maxit"="20", "acc"="1e-04", "test.vec"="resid", "lqs.control"="")
	/**
	 * 
	 * Fit a linear model by robust regression using an M estimator.
	 *
	 */
	function "rlm.formula"("formula", "data", "weights", "...", "subset", "na.action", "method"="c(\"M\", \"MM\", \"model.frame\")", "wt.method"="c(\"inv.var\", \"case\")", "model"="TRUE", "x.ret"="TRUE", "y.ret"="FALSE", "contrasts"="")
	/**
	 * 
	 *Calculates the root mean square parameter effects and intrinsic relative
	 *curvatures, \eqn{{c^\theta}{c^theta}} and \eqn{{c^\iota}{c^iota}}, for a
	 *fitted nonlinear regression, as defined in Bates & Watts, section 7.3,
	 *p. 253ff
	 *
	 */
	exported function "rms.curv"("obj")
	/**
	 * 
	 *Function to generate random outcomes from a Negative Binomial distribution,
	 *with mean \code{mu} and variance \code{mu + mu^2/theta}.
	 *
	 */
	exported function "rnegbin"("n", "mu", "theta"="stop(\"'theta' must be specified\")")
	function "safe_pchisq"("q", "df", "...")
	function "safe_pf"("q", "df1", "...")
	/**
	 * 
	 *One form of non-metric multidimensional scaling.
	 *
	 */
	exported function "sammon"("d", "y"="cmdscale(d, k)", "k"="2", "niter"="100", "trace"="TRUE", "magic"="0.2", "tol"="1e-04")
	function "se.contrast.rlm"("object", "contrast.obj", "coef"="contr.helmert(ncol(contrast))[, 1L]", "data"="", "...")
	/**
	 * 
	 *Fit a linear model by ridge regression.
	 *
	 */
	exported function "select"("obj")
	/**
	 * 
	 *Fit a linear model by ridge regression.
	 *
	 */
	function "select.ridgelm"("obj")
	/**
	 * 
	 *One form of non-metric multidimensional scaling
	 *
	 */
	exported function "Shepard"("d", "x", "p"="2")
	function "simulate.negbin"("object", "nsim"="1", "seed"="", "...")
	function "simulate.polr"("object", "nsim"="1", "seed"="", "...")
	/**
	 * 
	 *The standardized residuals.  These are normalized to unit
	 *variance, fitted including the current data point.
	 *
	 */
	exported function "stdres"("object")
	/**
	 * 
	 * Performs stepwise model selection by AIC.
	 *
	 */
	exported function "stepAIC"("object", "scope", "scale"="0", "direction"="c(\"both\", \"backward\", \"forward\")", "trace"="1", "keep"="", "steps"="1000", "use.start"="FALSE", "k"="2", "...")
	/**
	 * 
	 *The Studentized residuals.  Like standardized residuals, these are
	 *normalized to unit variance, but the Studentized version is fitted
	 *ignoring the current data point. (They are sometimes called jackknifed
	 *residuals).
	 *
	 */
	exported function "studres"("object")
	/**
	 * 
	 *Find rational approximations to the components of a real numeric
	 *object using a standard continued fraction method.
	 *
	 */
	function "Summary.fractions"("x", "...", "na.rm")
	/**
	 * 
	 *Returns a summary list for log-linear models fitted by
	 *iterative proportional scaling using \code{loglm}.
	 *
	 */
	function "summary.loglm"("object", "fitted"="FALSE", "...")
	/**
	 * 
	 *Identical to \code{summary.glm}, but with three lines of additional output: the
	 *ML estimate of theta, its standard error, and twice the log-likelihood
	 *function.
	 *
	 */
	function "summary.negbin"("object", "dispersion"="1", "correlation"="FALSE", "...")
	function "summary.polr"("object", "digits"="max(3, .Options$digits - 3)", "correlation"="FALSE", "...")
	/**
	 * 
	 *\code{summary} method for objects of class \code{"rlm"}
	 *
	 */
	function "summary.rlm"("object", "method"="c(\"XtX\", \"XtWX\")", "correlation"="FALSE", "...")
	/**
	 * 
	 *Find rational approximations to the components of a real numeric
	 *object using a standard continued fraction method.
	 *
	 */
	function "t.fractions"("x")
	/**
	 * 
	 * Performs stepwise model selection by AIC.
	 *
	 */
	function "terms.gls"("x", "...")
	/**
	 * 
	 * Performs stepwise model selection by AIC.
	 *
	 */
	function "terms.lme"("x", "...")
	/**
	 * 
	 * Given the estimated mean vector, estimate \code{theta} of the
	 * Negative Binomial Distribution.
	 *
	 */
	exported function "theta.md"("y", "mu", "dfr", "weights", "limit"="20", "eps"=".Machine$double.eps^0.25")
	/**
	 * 
	 * Given the estimated mean vector, estimate \code{theta} of the
	 * Negative Binomial Distribution.
	 *
	 */
	exported function "theta.ml"("y", "mu", "n"="sum(weights)", "weights", "limit"="10", "eps"=".Machine$double.eps^0.25", "trace"="FALSE")
	/**
	 * 
	 * Given the estimated mean vector, estimate \code{theta} of the
	 * Negative Binomial Distribution.
	 *
	 */
	exported function "theta.mm"("y", "mu", "dfr", "weights", "limit"="10", "eps"=".Machine$double.eps^0.25")
	/**
	 * 
	 *Creates a histogram on the current graphics device.
	 *
	 */
	exported function "truehist"("data", "nbins"="Scott", "h", "x0"="-h/1000", "breaks", "prob"="TRUE", "xlim"="range(breaks)", "ymax"="max(est)", "col"="cyan", "xlab"="deparse(substitute(data))", "bty"="n", "...")
	/**
	 * 
	 *Uses unbiased cross-validation to select the bandwidth of a Gaussian
	 *kernel density estimator.
	 *
	 */
	exported function "ucv"("x", "nb"="1000", "lower"="0.1 * hmax", "upper")
	function "update.loglm"("object", "formula", "...")
	function "vcov.fitdistr"("object", "...")
	function "vcov.negbin"("object", "...")
	function "vcov.polr"("object", "...")
	function "vcov.rlm"("object", "...")
	var "VR_bcv_bin"
	var "VR_den_bin"
	var "VR_mds_dovm"
	var "VR_mds_fn"
	var "VR_mds_init_data"
	var "VR_mds_unload"
	var "VR_phi4_bin"
	var "VR_phi6_bin"
	var "VR_sammon"
	var "VR_ucv_bin"
	/**
	 * 
	 *Uses the method of Sheather & Jones (1991) to select the bandwidth of
	 *a Gaussian kernel density estimator.
	 *
	 */
	exported function "width.SJ"("x", "nb"="1000", "lower"="0.1 * hmax", "upper", "method"="c(\"ste\", \"dpi\")")
	/**
	 * 
	 * Writes a matrix or data frame to a file or the console, using column
	 * labels and a layout respecting columns.
	 *
	 */
	exported function "write.matrix"("x", "file"="", "sep"=" ", "blocksize")
}
