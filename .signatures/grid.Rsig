package "grid" "3.3.1" {
	var ".__global__"
	var ".__NAMESPACE__."
	var ".__S3MethodsTable__."
	var ".grid.gpar.names"
	var ".grid.loaded"
	var ".grid.pathSep"
	var ".grid.unit.list"
	var ".GridEvalEnv"
	var ".noGenerics"
	function ".onLoad"("libname", "pkgname")
	function ".onUnload"("libpath")
	var ".packageName"
	function "[.arrow"("x", "index", "...")
	function "[.gList"("x", "index", "...")
	function "[.gpar"("x", "index", "...")
	function "[.unit"("x", "index", "top"="TRUE", "...")
	function "[.unit.arithmetic"("x", "index", "top"="TRUE", "...")
	function "[.unit.list"("x", "index", "top"="TRUE", "...")
	function "[.vpPath"("x", "index", "...")
	function "[<-.unit"("x", "i", "value")
	function "absolute"("unit")
	/**
	 * 
	 * This function converts a unit object into absolute units.
	 * Absolute units are unaffected, but non-absolute units are
	 * converted into \code{"null"} units.
	 *
	 */
	exported function "absolute.size"("unit")
	function "absolute.units"("unit")
	function "absolute.units.unit"("unit")
	function "absolute.units.unit.arithmetic"("unit")
	function "absolute.units.unit.list"("unit")
	function "addDLfromGPath"("gPath", "child", "strict", "grep", "global", "redraw")
	/**
	 * 
	 * Add a grob to a gTree or a descendant of a gTree.
	 *
	 */
	exported function "addGrob"("gTree", "child", "gPath"="", "strict"="FALSE", "grep"="FALSE", "global"="FALSE", "warn"="TRUE")
	function "addGrobFromGPath"("grob", "child", "pathsofar", "gPath", "strict", "grep", "global")
	function "addGrobFromGPath.default"("grob", "child", "pathsofar", "gPath", "strict", "grep", "global")
	function "addGrobFromGPath.grob"("grob", "child", "pathsofar", "gPath", "strict", "grep", "global")
	function "addGrobFromGPath.gTree"("grob", "child", "pathsofar", "gPath", "strict", "grep", "global")
	function "addGTree"("gTree", "grob", "pathsofar", "gPath", "strict", "grep", "global")
	function "addToGList"("x", "gList")
	function "addToGList.default"("x", "gList")
	function "addToGList.gList"("x", "gList")
	function "addToGList.grob"("x", "gList")
	function "addToGTree"("gTree", "child")
	/**
	 * 
	 * The functions \code{gEdit} and \code{gEditList} create
	 * objects representing an edit operation (essentially a list
	 * of arguments to \code{editGrob}).
	 *
	 * The functions \code{applyEdit} and \code{applyEdits} apply
	 * one or more edit operations to a graphical object.
	 *
	 * These functions are most useful for developers creating new
	 * graphical functions and objects.
	 *
	 */
	exported function "applyEdit"("x", "edit")
	/**
	 * 
	 * The functions \code{gEdit} and \code{gEditList} create
	 * objects representing an edit operation (essentially a list
	 * of arguments to \code{editGrob}).
	 *
	 * The functions \code{applyEdit} and \code{applyEdits} apply
	 * one or more edit operations to a graphical object.
	 *
	 * These functions are most useful for developers creating new
	 * graphical functions and objects.
	 *
	 */
	exported function "applyEdits"("x", "edits")
	/**
	 * 
	 * These functions create and draw a curve from one location
	 * to another.
	 *
	 */
	exported function "arcCurvature"("theta")
	/**
	 * 
	 * Produces a description of what arrows to add to a line.
	 * The result can be passed to a function that draws a line,
	 * e.g., \code{grid.lines}.
	 *
	 */
	exported function "arrow"("angle"="30", "length"="unit(0.25, \"inches\")", "ends"="last", "type"="open")
	/**
	 * 
	 * The functions or variables listed here are no longer part of \pkg{grid}.
	 *
	 */
	exported function "arrowsGrob"("x"="c(0.25, 0.75)", "y"="0.5", "default.units"="npc", "grob"="", "angle"="30", "length"="unit(0.25, \"inches\")", "ends"="last", "type"="open", "name"="", "gp"="gpar()", "vp"="")
	function "as.character.gList"("x", "...")
	function "as.character.grob"("x", "...")
	function "as.character.path"("x", "...")
	function "as.character.unit"("x", "...")
	function "as.character.unit.arithmetic"("x", "...")
	function "as.character.unit.list"("x", "...")
	function "as.character.viewport"("x", "...")
	function "as.character.vpList"("x", "...")
	function "as.character.vpStack"("x", "...")
	function "as.character.vpTree"("x", "...")
	function "as.gList"("x")
	/**
	 * 
	 * These generic functions are used to determine the size of grid grobs.
	 *
	 */
	exported function "ascentDetails"("x")
	function "ascentDetails.default"("x")
	function "ascentDetails.grob"("x")
	function "ascentDetails.text"("x")
	/**
	 * 
	 * These functions create and draw Bezier Curves (a curve drawn
	 * relative to 4 control points).
	 *
	 */
	exported function "bezierGrob"("x"="c(0, 0.5, 1, 0.5)", "y"="c(0.5, 1, 0.5, 0)", "id"="", "id.lengths"="", "default.units"="npc", "arrow"="", "name"="", "gp"="gpar()", "vp"="")
	/**
	 * 
	 * Rather than drawing an Xspline (or Bezier curve), this function returns
	 * the points that would be used to draw the series of line
	 * segments for the Xspline.  This may be useful to post-process
	 * the Xspline curve, for example, to clip the curve.
	 *
	 */
	exported function "bezierPoints"("x")
	function "buildPath"("desc", "anc", "depth")
	function "calcControlPoints"("x1", "y1", "x2", "y2", "curvature", "angle", "ncp", "debug"="FALSE")
	function "calcCurveGrob"("x", "debug")
	function "calcOrigin"("x1", "y1", "x2", "y2", "origin", "hand")
	function "calcSquareControlPoints"("x1", "y1", "x2", "y2", "curvature", "angle", "ncp", "debug"="FALSE")
	/**
	 * 
	 * This function returns the ascent, descent, and width metric
	 * information for a character or expression vector.
	 *
	 */
	exported function "calcStringMetric"("text")
	function "cbDiagram"("x1", "y1", "x2", "y2", "cps")
	function "cellGrob"("col", "row", "border", "grob", "dynamic", "vp")
	function "cellViewport"("col", "row", "border")
	function "checkgpSlot"("gp")
	function "checkNameSlot"("x")
	function "checkvpSlot"("vp")
	function "child.exists"("name", "children")
	function "child.list"("children")
	function "childName"("x")
	/**
	 * 
	 * Creating grid graphical objects, short (\dQuote{grob}s).
	 *
	 * \code{grob()} and \code{gTree()} are the basic creators,
	 * \code{grobTree()} and \code{gList()} take several grobs to build a new
	 * one.
	 *
	 */
	exported function "childNames"("gTree")
	/**
	 * 
	 * Functions to create and draw a circle.
	 *
	 */
	exported function "circleGrob"("x"="0.5", "y"="0.5", "r"="0.5", "default.units"="npc", "name"="", "gp"="gpar()", "vp"="")
	function "clean"("paths")
	/**
	 * 
	 * These functions set the clipping region within the current viewport
	 * \emph{without} altering the current coordinate system.
	 *
	 */
	exported function "clipGrob"("x"="unit(0.5, \"npc\")", "y"="unit(0.5, \"npc\")", "width"="unit(1, \"npc\")", "height"="unit(1, \"npc\")", "just"="centre", "hjust"="", "vjust"="", "default.units"="npc", "name"="", "vp"="")
	function "col.spec"("side", "col", "col.before", "col.after", "ncol")
	/**
	 * 
	 * These functions take a unit object and convert it to an
	 * equivalent
	 * unit object in a different coordinate system.
	 *
	 */
	exported function "convertHeight"("x", "unitTo", "valueOnly"="FALSE")
	/**
	 * 
	 * The functions or variables listed here are no longer part of \pkg{grid}.
	 *
	 */
	exported function "convertNative"("unit", "dimension"="x", "type"="location")
	function "convertTheta"("theta")
	/**
	 * 
	 * These functions take a unit object and convert it to an
	 * equivalent
	 * unit object in a different coordinate system.
	 *
	 */
	exported function "convertUnit"("x", "unitTo", "axisFrom"="x", "typeFrom"="location", "axisTo", "typeTo", "valueOnly"="FALSE")
	/**
	 * 
	 * These functions take a unit object and convert it to an
	 * equivalent
	 * unit object in a different coordinate system.
	 *
	 */
	exported function "convertWidth"("x", "unitTo", "valueOnly"="FALSE")
	/**
	 * 
	 * These functions take a unit object and convert it to an
	 * equivalent
	 * unit object in a different coordinate system.
	 *
	 */
	exported function "convertX"("x", "unitTo", "valueOnly"="FALSE")
	/**
	 * 
	 * These functions take a unit object and convert it to an
	 * equivalent
	 * unit object in a different coordinate system.
	 *
	 */
	exported function "convertY"("x", "unitTo", "valueOnly"="FALSE")
	/**
	 * 
	 * \code{current.viewport()}
	 * returns the viewport that Grid is going to draw into.
	 *
	 * \code{current.parent} returns the parent of the current viewport.
	 * 
	 * \code{current.vpTree} returns the entire Grid viewport tree.
	 *
	 * \code{current.vpPath} returns the viewport path to the current viewport.
	 *
	 * \code{current.transform} returns the transformation
	 * matrix for the current viewport.
	 *
	 * \code{current.rotation} returns the (total) rotation
	 * for the current viewport.
	 *
	 */
	exported function "current.parent"("n"="1")
	/**
	 * 
	 * \code{current.viewport()}
	 * returns the viewport that Grid is going to draw into.
	 *
	 * \code{current.parent} returns the parent of the current viewport.
	 * 
	 * \code{current.vpTree} returns the entire Grid viewport tree.
	 *
	 * \code{current.vpPath} returns the viewport path to the current viewport.
	 *
	 * \code{current.transform} returns the transformation
	 * matrix for the current viewport.
	 *
	 * \code{current.rotation} returns the (total) rotation
	 * for the current viewport.
	 *
	 */
	exported function "current.rotation"()
	/**
	 * 
	 * \code{current.viewport()}
	 * returns the viewport that Grid is going to draw into.
	 *
	 * \code{current.parent} returns the parent of the current viewport.
	 * 
	 * \code{current.vpTree} returns the entire Grid viewport tree.
	 *
	 * \code{current.vpPath} returns the viewport path to the current viewport.
	 *
	 * \code{current.transform} returns the transformation
	 * matrix for the current viewport.
	 *
	 * \code{current.rotation} returns the (total) rotation
	 * for the current viewport.
	 *
	 */
	exported function "current.transform"()
	/**
	 * 
	 * \code{current.viewport()}
	 * returns the viewport that Grid is going to draw into.
	 *
	 * \code{current.parent} returns the parent of the current viewport.
	 * 
	 * \code{current.vpTree} returns the entire Grid viewport tree.
	 *
	 * \code{current.vpPath} returns the viewport path to the current viewport.
	 *
	 * \code{current.transform} returns the transformation
	 * matrix for the current viewport.
	 *
	 * \code{current.rotation} returns the (total) rotation
	 * for the current viewport.
	 *
	 */
	exported function "current.viewport"()
	function "current.vpList"()
	function "current.vpNames"()
	/**
	 * 
	 * \code{current.viewport()}
	 * returns the viewport that Grid is going to draw into.
	 *
	 * \code{current.parent} returns the parent of the current viewport.
	 * 
	 * \code{current.vpTree} returns the entire Grid viewport tree.
	 *
	 * \code{current.vpPath} returns the viewport path to the current viewport.
	 *
	 * \code{current.transform} returns the transformation
	 * matrix for the current viewport.
	 *
	 * \code{current.rotation} returns the (total) rotation
	 * for the current viewport.
	 *
	 */
	exported function "current.vpPath"()
	/**
	 * 
	 * \code{current.viewport()}
	 * returns the viewport that Grid is going to draw into.
	 *
	 * \code{current.parent} returns the parent of the current viewport.
	 * 
	 * \code{current.vpTree} returns the entire Grid viewport tree.
	 *
	 * \code{current.vpPath} returns the viewport path to the current viewport.
	 *
	 * \code{current.transform} returns the transformation
	 * matrix for the current viewport.
	 *
	 * \code{current.rotation} returns the (total) rotation
	 * for the current viewport.
	 *
	 */
	exported function "current.vpTree"("all"="TRUE")
	/**
	 * 
	 * These functions create and draw a curve from one location
	 * to another.
	 *
	 */
	exported function "curveGrob"("x1", "y1", "x2", "y2", "default.units"="npc", "curvature"="1", "angle"="90", "ncp"="1", "shape"="0.5", "square"="TRUE", "squareShape"="1", "inflect"="FALSE", "arrow"="", "open"="TRUE", "debug"="FALSE", "name"="", "gp"="gpar()", "vp"="")
	function "dataUnit"("unit")
	/**
	 * 
	 * This is a convenience function for producing a viewport with
	 * x- and/or y-scales based on numeric values passed to the function.
	 *
	 */
	exported function "dataViewport"("xData"="", "yData"="", "xscale"="", "yscale"="", "extension"="0.05", "...")
	function "decrDepth"("depth", "x")
	function "decrPath"("oldpath", "x")
	/**
	 * 
	 * Evaluates an expression that includes both calculations
	 * and generating a grob that depends on the calculations so that
	 * both the calculations and the grob generation will be rerun when
	 * the scene is redrawn (e.g., device resize or editing).
	 *
	 * Intended \emph{only} for expert use.
	 *
	 */
	function "delayGrob"("expr", "list", "name"="", "gp"="", "vp"="")
	/**
	 * 
	 * Determine the number of levels in a viewport stack or tree,
	 * in a viewport path, or in a grob path.
	 *
	 */
	exported function "depth"("x", "...")
	/**
	 * 
	 * Determine the number of levels in a viewport stack or tree,
	 * in a viewport path, or in a grob path.
	 *
	 */
	function "depth.path"("x", "...")
	/**
	 * 
	 * Determine the number of levels in a viewport stack or tree,
	 * in a viewport path, or in a grob path.
	 *
	 */
	function "depth.viewport"("x", "...")
	function "depth.vpList"("x", "...")
	function "depth.vpStack"("x", "...")
	function "depth.vpTree"("x", "...")
	/**
	 * 
	 * These generic functions are used to determine the size of grid grobs.
	 *
	 */
	exported function "descentDetails"("x")
	function "descentDetails.default"("x")
	function "descentDetails.text"("x")
	function "dim.layout"("x")
	/**
	 * 
	 * Grid maintains a tree of viewports --- nested drawing
	 * contexts.
	 *
	 * These functions provide ways to add or remove viewports
	 * and to navigate amongst viewports in the tree.
	 *
	 */
	exported function "downViewport"("name", "strict"="FALSE", "recording"="TRUE")
	function "downViewport.default"("name", "strict"="FALSE", "recording"="TRUE")
	function "downViewport.vpPath"("name", "strict"="FALSE", "recording"="TRUE")
	function "draw.all"()
	/**
	 * 
	 * The functions or variables listed here are no longer part of \pkg{grid}.
	 *
	 */
	exported function "draw.details"("x", "recording")
	/**
	 * 
	 * These generic hook functions are called whenever a grid grob is drawn.
	 * They provide an opportunity for customising the drawing of a
	 * new class derived from grob (or gTree).
	 *
	 */
	exported function "drawDetails"("x", "recording")
	function "drawDetails.arrows"("x", "recording"="TRUE")
	function "drawDetails.circle"("x", "recording"="TRUE")
	function "drawDetails.clip"("x", "recording"="TRUE")
	function "drawDetails.grob"("x", "recording")
	function "drawDetails.groblabel"("x", "...")
	function "drawDetails.line.to"("x", "recording"="TRUE")
	function "drawDetails.lines"("x", "recording"="TRUE")
	function "drawDetails.move.to"("x", "recording"="TRUE")
	function "drawDetails.null"("x", "recording"="TRUE")
	function "drawDetails.pathgrob"("x", "recording"="TRUE")
	function "drawDetails.points"("x", "recording"="TRUE")
	function "drawDetails.polygon"("x", "recording"="TRUE")
	function "drawDetails.polyline"("x", "recording"="TRUE")
	function "drawDetails.rastergrob"("x", "recording"="TRUE")
	function "drawDetails.recordedGrob"("x", "recording")
	function "drawDetails.rect"("x", "recording"="TRUE")
	function "drawDetails.segments"("x", "recording"="TRUE")
	function "drawDetails.text"("x", "recording"="TRUE")
	function "drawDetails.xspline"("x", "recording"="TRUE")
	function "drawGList"("x")
	function "drawGrob"("x")
	function "drawGTree"("x")
	function "drawPath"("path", "depth", "col", "fill", "label")
	function "drawVP"("vp", "curDepth", "depth", "col", "fill", "label")
	function "drawVP.viewport"("vp", "curDepth", "depth", "col", "fill", "label")
	function "drawVP.vpList"("vp", "curDepth", "depth", "col", "fill", "label")
	function "drawVP.vpPath"("vp", "curDepth", "depth", "col", "fill", "label")
	function "drawVP.vpStack"("vp", "curDepth", "depth", "col", "fill", "label")
	function "drawVP.vpTree"("vp", "curDepth", "depth", "col", "fill", "label")
	/**
	 * 
	 * This generic hook function is called whenever a grid grob is edited
	 * via \code{grid.edit} or \code{editGrob}.
	 * This provides an opportunity for customising the editing of a
	 * new class derived from grob (or gTree).
	 *
	 */
	exported function "editDetails"("x", "specs")
	function "editDetails.default"("x", "specs")
	function "editDetails.gTree"("x", "specs")
	function "editDetails.xaxis"("x", "specs")
	function "editDetails.yaxis"("x", "specs")
	function "editDLfromGPath"("gPath", "specs", "strict", "grep", "global", "redraw")
	/**
	 * 
	 * Changes the value of one of the slots of a grob
	 *and redraws the grob.
	 *
	 */
	exported function "editGrob"("grob", "gPath"="", "...", "strict"="FALSE", "grep"="FALSE", "global"="FALSE", "warn"="TRUE")
	function "editGrobFromGPath"("grob", "specs", "pathsofar", "gPath", "strict", "grep", "global")
	function "editGrobFromGPath.default"("grob", "specs", "pathsofar", "gPath", "strict", "grep", "global")
	function "editGrobFromGPath.grob"("grob", "specs", "pathsofar", "gPath", "strict", "grep", "global")
	function "editGrobFromGPath.gTree"("grob", "specs", "pathsofar", "gPath", "strict", "grep", "global")
	function "editGTree"("gTree", "specs", "pathsofar", "gPath", "strict", "grep", "global")
	function "editThisGrob"("grob", "specs")
	/**
	 * 
	 * Turn the Grid display list on or off.
	 *
	 */
	exported function "engine.display.list"("on"="TRUE")
	/**
	 * 
	 * Explode a viewport path or grob path into its components.
	 *
	 */
	exported function "explode"("x")
	/**
	 * 
	 * Explode a viewport path or grob path into its components.
	 *
	 */
	function "explode.character"("x")
	/**
	 * 
	 * Explode a viewport path or grob path into its components.
	 *
	 */
	function "explode.path"("x")
	function "findgrob"("x", "name")
	function "findgrob.default"("x", "name")
	function "findgrob.grob"("x", "name")
	function "findGrobinChildren"("name", "children")
	function "findGrobinDL"("name")
	function "flatListing"("x", "gDepth"="0", "vpDepth"="0", "gPath"="", "vpPath"="")
	function "flatListing.gridListing"("x", "gDepth"="0", "vpDepth"="0", "gPath"="", "vpPath"="")
	function "flatListing.gridListListing"("x", "gDepth"="0", "vpDepth"="0", "gPath"="", "vpPath"="")
	function "flatListing.gTreeListing"("x", "gDepth"="0", "vpDepth"="0", "gPath"="", "vpPath"="")
	function "flatListing.vpNameTreeListing"("x", "gDepth"="0", "vpDepth"="0", "gPath"="", "vpPath"="")
	function "flatListing.vpTreeListing"("x", "gDepth"="0", "vpDepth"="0", "gPath"="", "vpPath"="")
	function "flattenListing"("x")
	/**
	 * 
	 * Some grobs only generate their content to draw at
	 * drawing time;  this function replaces such grobs with
	 * their at-drawing-time content.
	 *
	 */
	exported function "forceGrob"("x")
	function "forceGrob.default"("x")
	function "forceGrob.grob"("x")
	function "forceGrob.gTree"("x")
	function "frameDim"("frame")
	/**
	 * 
	 * These functions, together with \code{grid.pack},
	 * \code{grid.place}, \code{packGrob}, and \code{placeGrob} are part of a
	 * GUI-builder-like interface to constructing graphical images.
	 * The idea is that you create a frame with this function then
	 * use \code{grid.pack} or whatever to pack/place objects into the frame.
	 *
	 */
	exported function "frameGrob"("layout"="", "name"="", "gp"="gpar()", "vp"="")
	function "fullPathMatch"("pathsofar", "gPath", "strict", "grep")
	/**
	 * 
	 * Draw a curve representing a function.
	 *
	 */
	exported function "functionGrob"("f", "n"="101", "range"="x", "units"="native", "name"="", "gp"="gpar()", "vp"="")
	/**
	 * 
	 * The functions \code{gEdit} and \code{gEditList} create
	 * objects representing an edit operation (essentially a list
	 * of arguments to \code{editGrob}).
	 *
	 * The functions \code{applyEdit} and \code{applyEdits} apply
	 * one or more edit operations to a graphical object.
	 *
	 * These functions are most useful for developers creating new
	 * graphical functions and objects.
	 *
	 */
	exported function "gEdit"("...")
	/**
	 * 
	 * The functions \code{gEdit} and \code{gEditList} create
	 * objects representing an edit operation (essentially a list
	 * of arguments to \code{editGrob}).
	 *
	 * The functions \code{applyEdit} and \code{applyEdits} apply
	 * one or more edit operations to a graphical object.
	 *
	 * These functions are most useful for developers creating new
	 * graphical functions and objects.
	 *
	 */
	exported function "gEditList"("...")
	function "genXY"("x")
	/**
	 * 
	 * \code{gpar()} should be used to create a set of graphical
	 * parameter settings.  It returns an object of class \code{"gpar"}.  This is
	 * basically a list of name-value pairs.
	 *
	 * \code{get.gpar()} can be used to query the current
	 * graphical parameter settings.
	 *
	 */
	exported function "get.gpar"("names"="")
	function "getDLfromGPath"("gPath", "strict", "grep", "global")
	/**
	 * 
	 * Retrieve a grob or a descendant of a grob.
	 *
	 */
	exported function "getGrob"("gTree", "gPath", "strict"="FALSE", "grep"="FALSE", "global"="FALSE")
	function "getGrobFromGPath"("grob", "pathsofar", "gPath", "strict", "grep", "global")
	function "getGrobFromGPath.default"("grob", "pathsofar", "gPath", "strict", "grep", "global")
	function "getGrobFromGPath.grob"("grob", "pathsofar", "gPath", "strict", "grep", "global")
	function "getGrobFromGPath.gTree"("grob", "pathsofar", "gPath", "strict", "grep", "global")
	function "getGTree"("gTree", "pathsofar", "gPath", "strict", "grep", "global")
	function "getName"("elt")
	/**
	 * 
	 * Returns a character vector containing the names of all
	 * top-level grobs on the display list.
	 *
	 */
	exported function "getNames"()
	/**
	 * 
	 * Creating grid graphical objects, short (\dQuote{grob}s).
	 *
	 * \code{grob()} and \code{gTree()} are the basic creators,
	 * \code{grobTree()} and \code{gList()} take several grobs to build a new
	 * one.
	 *
	 */
	exported function "gList"("...")
	/**
	 * 
	 * \code{gpar()} should be used to create a set of graphical
	 * parameter settings.  It returns an object of class \code{"gpar"}.  This is
	 * basically a list of name-value pairs.
	 *
	 * \code{get.gpar()} can be used to query the current
	 * graphical parameter settings.
	 *
	 */
	exported function "gpar"("...")
	/**
	 * 
	 * This function can be used to generate a grob path for use
	 * in \code{grid.edit} and friends.
	 *
	 * A grob path is a list of nested grob names.
	 *
	 */
	exported function "gPath"("...")
	function "gPathFromVector"("names")
	function "grabDL"("warn", "wrap", "...")
	/**
	 * 
	 * Draw a curve representing a function.
	 *
	 */
	exported function "grid.abline"("intercept"="0", "slope"="1", "...")
	/**
	 * 
	 * Add a grob to a gTree or a descendant of a gTree.
	 *
	 */
	exported function "grid.add"("gPath", "child", "strict"="FALSE", "grep"="FALSE", "global"="FALSE", "allDevices"="FALSE", "redraw"="TRUE")
	/**
	 * 
	 * The functions or variables listed here are no longer part of \pkg{grid}.
	 *
	 */
	exported function "grid.arrows"("x"="c(0.25, 0.75)", "y"="0.5", "default.units"="npc", "grob"="", "angle"="30", "length"="unit(0.25, \"inches\")", "ends"="last", "type"="open", "name"="", "gp"="gpar()", "draw"="TRUE", "vp"="")
	/**
	 * 
	 * These functions create and draw Bezier Curves (a curve drawn
	 * relative to 4 control points).
	 *
	 */
	exported function "grid.bezier"("...")
	function "grid.Call"("fnname", "...")
	function "grid.Call.graphics"("fnname", "...")
	/**
	 * 
	 * Capture the current contents of a graphics device as a raster
	 * (bitmap) image.
	 *
	 */
	exported function "grid.cap"()
	/**
	 * 
	 * Functions to create and draw a circle.
	 *
	 */
	exported function "grid.circle"("x"="0.5", "y"="0.5", "r"="0.5", "default.units"="npc", "name"="", "gp"="gpar()", "draw"="TRUE", "vp"="")
	/**
	 * 
	 * These functions set the clipping region within the current viewport
	 * \emph{without} altering the current coordinate system.
	 *
	 */
	exported function "grid.clip"("...")
	/**
	 * 
	 * The functions or variables listed here are no longer part of \pkg{grid}.
	 *
	 */
	exported function "grid.collection"("...", "gp"="gpar()", "draw"="TRUE", "vp"="")
	/**
	 * 
	 * The functions or variables listed here are no longer part of \pkg{grid}.
	 *
	 */
	exported function "grid.convert"("x", "unitTo", "axisFrom"="x", "typeFrom"="location", "axisTo", "typeTo", "valueOnly"="FALSE")
	/**
	 * 
	 * The functions or variables listed here are no longer part of \pkg{grid}.
	 *
	 */
	exported function "grid.convertHeight"("x", "unitTo", "valueOnly"="FALSE")
	/**
	 * 
	 * The functions or variables listed here are no longer part of \pkg{grid}.
	 *
	 */
	exported function "grid.convertWidth"("x", "unitTo", "valueOnly"="FALSE")
	/**
	 * 
	 * The functions or variables listed here are no longer part of \pkg{grid}.
	 *
	 */
	exported function "grid.convertX"("x", "unitTo", "valueOnly"="FALSE")
	/**
	 * 
	 * The functions or variables listed here are no longer part of \pkg{grid}.
	 *
	 */
	exported function "grid.convertY"("x", "unitTo", "valueOnly"="FALSE")
	/**
	 * 
	 * This function is redundant and will disappear in future versions.
	 *
	 */
	exported function "grid.copy"("grob")
	/**
	 * 
	 * These functions create and draw a curve from one location
	 * to another.
	 *
	 */
	exported function "grid.curve"("...")
	/**
	 * 
	 * Evaluates an expression that includes both calculations
	 * and generating a grob that depends on the calculations so that
	 * both the calculations and the grob generation will be rerun when
	 * the scene is redrawn (e.g., device resize or editing).
	 *
	 * Intended \emph{only} for expert use.
	 *
	 */
	exported function "grid.delay"("expr", "list", "name"="", "gp"="", "vp"="")
	/**
	 * 
	 * Turn the Grid display list on or off.
	 *
	 */
	exported function "grid.display.list"("on"="TRUE")
	/**
	 * 
	 * Call a function on each element of the current display list.
	 *
	 */
	exported function "grid.DLapply"("FUN", "...")
	/**
	 * 
	 * Produces graphical output from a graphical object.
	 *
	 */
	exported function "grid.draw"("x", "recording"="TRUE")
	function "grid.draw.gList"("x", "recording"="TRUE")
	function "grid.draw.grob"("x", "recording"="TRUE")
	function "grid.draw.gTree"("x", "recording"="TRUE")
	function "grid.draw.pop"("x", "recording")
	function "grid.draw.up"("x", "recording")
	function "grid.draw.viewport"("x", "recording")
	function "grid.draw.vpPath"("x", "recording")
	/**
	 * 
	 * Changes the value of one of the slots of a grob
	 *and redraws the grob.
	 *
	 */
	exported function "grid.edit"("gPath", "...", "strict"="FALSE", "grep"="FALSE", "global"="FALSE", "allDevices"="FALSE", "redraw"="TRUE")
	/**
	 * 
	 * Some grobs only generate their content to draw at
	 * drawing time;  this function replaces such grobs with
	 * their at-drawing-time content.
	 *
	 */
	exported function "grid.force"("x", "...")
	function "grid.force.character"("x", "...")
	/**
	 * 
	 * Some grobs only generate their content to draw at
	 * drawing time;  this function replaces such grobs with
	 * their at-drawing-time content.
	 *
	 */
	function "grid.force.default"("x", "redraw"="FALSE", "...")
	/**
	 * 
	 * Some grobs only generate their content to draw at
	 * drawing time;  this function replaces such grobs with
	 * their at-drawing-time content.
	 *
	 */
	function "grid.force.gPath"("x", "strict"="FALSE", "grep"="FALSE", "global"="FALSE", "redraw"="FALSE", "...")
	/**
	 * 
	 * Some grobs only generate their content to draw at
	 * drawing time;  this function replaces such grobs with
	 * their at-drawing-time content.
	 *
	 */
	function "grid.force.grob"("x", "draw"="FALSE", "...")
	/**
	 * 
	 * These functions, together with \code{grid.pack},
	 * \code{grid.place}, \code{packGrob}, and \code{placeGrob} are part of a
	 * GUI-builder-like interface to constructing graphical images.
	 * The idea is that you create a frame with this function then
	 * use \code{grid.pack} or whatever to pack/place objects into the frame.
	 *
	 */
	exported function "grid.frame"("layout"="", "name"="", "gp"="gpar()", "vp"="", "draw"="TRUE")
	/**
	 * 
	 * Draw a curve representing a function.
	 *
	 */
	exported function "grid.function"("...")
	/**
	 * 
	 * Changes the value of one of the slots of a grob
	 *and redraws the grob.
	 *
	 */
	exported function "grid.gedit"("...", "grep"="TRUE", "global"="TRUE")
	/**
	 * 
	 * Retrieve a grob or a descendant of a grob.
	 *
	 */
	exported function "grid.get"("gPath", "strict"="FALSE", "grep"="FALSE", "global"="FALSE", "allDevices"="FALSE")
	/**
	 * 
	 * Retrieve a grob or a descendant of a grob.
	 *
	 */
	exported function "grid.gget"("...", "grep"="TRUE", "global"="TRUE")
	/**
	 * 
	 * Creates a gTree object from the current grid display list
	 * or from a scene generated by user-specified code.
	 *
	 */
	exported function "grid.grab"("warn"="2", "wrap"="FALSE", "...")
	/**
	 * 
	 * Creates a gTree object from the current grid display list
	 * or from a scene generated by user-specified code.
	 *
	 */
	exported function "grid.grabExpr"("expr", "warn"="2", "wrap"="FALSE", "...")
	/**
	 * 
	 * Remove a grob from a gTree or a descendant of a gTree.
	 *
	 */
	exported function "grid.gremove"("...", "grep"="TRUE", "global"="TRUE")
	/**
	 * 
	 * Given a gPath, find all matching grobs on the display list
	 * or within a given grob.
	 *
	 */
	exported function "grid.grep"("path", "x"="", "grobs"="TRUE", "viewports"="FALSE", "strict"="FALSE", "grep"="FALSE", "global"="FALSE", "no.match"="character()")
	/**
	 * 
	 * This function draws a grill within a Grid viewport.
	 *
	 */
	exported function "grid.grill"("h"="unit(seq(0.25, 0.75, 0.25), \"npc\")", "v"="unit(seq(0.25, 0.75, 0.25), \"npc\")", "default.units"="npc", "gp"="gpar(col = \"grey\")", "vp"="")
	/**
	 * 
	 * The functions or variables listed here are no longer part of \pkg{grid}.
	 *
	 */
	exported function "grid.grob"("list.struct", "cl"="", "draw"="TRUE")
	/**
	 * 
	 * This function returns a Grid layout, which describes a subdivision
	 * of a rectangular region.
	 *
	 */
	exported function "grid.layout"("nrow"="1", "ncol"="1", "widths"="unit(rep_len(1, ncol), \"null\")", "heights"="unit(rep_len(1, nrow), \"null\")", "default.units"="null", "respect"="FALSE", "just"="centre")
	/**
	 * 
	 * Constructing a legend grob (in progress)
	 *
	 */
	exported function "grid.legend"("...", "draw"="TRUE")
	/**
	 * 
	 * Grid has the notion of a current location.  These functions
	 * sets that location.
	 *
	 */
	exported function "grid.line.to"("x"="1", "y"="1", "default.units"="npc", "arrow"="", "name"="", "gp"="gpar()", "draw"="TRUE", "vp"="")
	/**
	 * 
	 * These functions create and draw a series of lines.
	 *
	 */
	exported function "grid.lines"("x"="unit(c(0, 1), \"npc\")", "y"="unit(c(0, 1), \"npc\")", "default.units"="npc", "arrow"="", "name"="", "gp"="gpar()", "draw"="TRUE", "vp"="")
	/**
	 * 
	 * Allows the user to click the mouse once within the current
	 * graphics
	 * device and returns the location of the mouse click within the
	 * current viewport, in the specified coordinate system.
	 *
	 */
	exported function "grid.locator"("unit"="native")
	/**
	 * 
	 * Return a listing of the names of grobs or viewports.
	 *
	 * This is a generic function with methods for grobs (including
	 * gTrees) and viewports (including vpTrees).
	 *
	 */
	exported function "grid.ls"("x"="", "grobs"="TRUE", "viewports"="FALSE", "fullNames"="FALSE", "recursive"="TRUE", "print"="TRUE", "flatten"="TRUE", "...")
	/**
	 * 
	 * Grid has the notion of a current location.  These functions
	 * sets that location.
	 *
	 */
	exported function "grid.move.to"("x"="0", "y"="0", "default.units"="npc", "name"="", "draw"="TRUE", "vp"="")
	/**
	 * 
	 * Internal Grid functions
	 *
	 */
	exported function "grid.multipanel"("x"="stats::runif(90)", "y"="stats::runif(90)", "z"="stats::runif(90)", "nplots"="9", "nrow"="5", "ncol"="2", "newpage"="TRUE", "vp"="")
	/**
	 * 
	 * This function erases the current device or moves to a new page.
	 *
	 */
	exported function "grid.newpage"("recording"="TRUE")
	/**
	 * 
	 * These functions create a NULL graphical object,
	 * which has zero width, zero height, and draw nothing.
	 * It can be used as a place-holder or as an invisible
	 * reference point for other drawing.
	 *
	 */
	exported function "grid.null"("...")
	/**
	 * 
	 * these functions, together with \code{grid.frame} and \code{frameGrob}
	 * are part of a
	 * GUI-builder-like interface to constructing graphical images.
	 * The idea is that you create a frame with \code{grid.frame} or
	 * \code{frameGrob} then
	 * use these functions to pack objects into the frame.
	 *
	 */
	exported function "grid.pack"("gPath", "grob", "redraw"="TRUE", "side"="", "row"="", "row.before"="", "row.after"="", "col"="", "col.before"="", "col.after"="", "width"="", "height"="", "force.width"="FALSE", "force.height"="FALSE", "border"="", "dynamic"="FALSE")
	/**
	 * 
	 * Internal Grid functions
	 *
	 */
	exported function "grid.panel"("x"="stats::runif(10)", "y"="stats::runif(10)", "zrange"="c(0, 1)", "zbin"="stats::runif(2)", "xscale"="extendrange(x)", "yscale"="extendrange(y)", "axis.left"="TRUE", "axis.left.label"="TRUE", "axis.right"="FALSE", "axis.right.label"="TRUE", "axis.bottom"="TRUE", "axis.bottom.label"="TRUE", "axis.top"="FALSE", "axis.top.label"="TRUE", "vp"="")
	/**
	 * 
	 * These functions create and draw a path.
	 * The final point will automatically
	 * be connected to the initial point.
	 *
	 */
	exported function "grid.path"("...")
	/**
	 * 
	 * These functions provide a simpler (and faster) alternative
	 * to the \code{grid.pack()} and \code{packGrob}
	 * functions.  They can be used to place objects within the existing
	 * rows and columns of a frame layout.  They do not provide the ability to
	 * add new rows and columns nor do they affect the
	 * heights and widths of the rows and columns.
	 *
	 */
	exported function "grid.place"("gPath", "grob", "row"="1", "col"="1", "redraw"="TRUE")
	/**
	 * 
	 * This function is just a wrapper for a simple demonstration of how
	 * a basic plot and legend can be drawn from scratch using grid.
	 *
	 */
	exported function "grid.plot.and.legend"()
	/**
	 * 
	 * These functions create and draw data symbols.
	 *
	 */
	exported function "grid.points"("x"="stats::runif(10)", "y"="stats::runif(10)", "pch"="1", "size"="unit(1, \"char\")", "default.units"="native", "name"="", "gp"="gpar()", "draw"="TRUE", "vp"="")
	/**
	 * 
	 * These functions create and draw a polygon.
	 * The final point will automatically
	 * be connected to the initial point.
	 *
	 */
	exported function "grid.polygon"("x"="c(0, 0.5, 1, 0.5)", "y"="c(0.5, 1, 0.5, 0)", "id"="", "id.lengths"="", "default.units"="npc", "name"="", "gp"="gpar()", "draw"="TRUE", "vp"="")
	/**
	 * 
	 * These functions create and draw a series of lines.
	 *
	 */
	exported function "grid.polyline"("...")
	/**
	 * 
	 * Produces a pretty set of breakpoints within the range given.
	 *
	 */
	exported function "grid.pretty"("range")
	/**
	 * 
	 * Render a raster object (bitmap image) at the given location, size,
	 * and orientation.
	 *
	 */
	exported function "grid.raster"("image", "x"="unit(0.5, \"npc\")", "y"="unit(0.5, \"npc\")", "width"="", "height"="", "just"="centre", "hjust"="", "vjust"="", "interpolate"="TRUE", "default.units"="npc", "name"="", "gp"="gpar()", "vp"="")
	/**
	 * 
	 * Evaluates an expression that includes both calculations
	 * and drawing that depends on the calculations so that
	 * both the calculations and the drawing will be rerun when
	 * the scene is redrawn (e.g., device resize or editing).
	 *
	 * Intended \emph{only} for expert use.
	 *
	 */
	exported function "grid.record"("expr", "list", "name"="", "gp"="", "vp"="")
	/**
	 * 
	 * These functions create and draw rectangles.
	 *
	 */
	exported function "grid.rect"("x"="unit(0.5, \"npc\")", "y"="unit(0.5, \"npc\")", "width"="unit(1, \"npc\")", "height"="unit(1, \"npc\")", "just"="centre", "hjust"="", "vjust"="", "default.units"="npc", "name"="", "gp"="gpar()", "draw"="TRUE", "vp"="")
	/**
	 * 
	 * Replays the current grid display list.
	 *
	 */
	exported function "grid.refresh"()
	/**
	 * 
	 * Remove a grob from a gTree or a descendant of a gTree.
	 *
	 */
	exported function "grid.remove"("gPath", "warn"="TRUE", "strict"="FALSE", "grep"="FALSE", "global"="FALSE", "allDevices"="FALSE", "redraw"="TRUE")
	/**
	 * 
	 * Change the order in which the children of a gTree get drawn.
	 *
	 */
	exported function "grid.reorder"("gPath", "order", "back"="TRUE", "grep"="FALSE", "redraw"="TRUE")
	/**
	 * 
	 * Some grobs only generate their content to draw at
	 * drawing time;  this function replaces such grobs with
	 * their at-drawing-time content.
	 *
	 */
	exported function "grid.revert"("x", "...")
	function "grid.revert.character"("x", "...")
	function "grid.revert.default"("x", "redraw"="FALSE", "...")
	/**
	 * 
	 * Some grobs only generate their content to draw at
	 * drawing time;  this function replaces such grobs with
	 * their at-drawing-time content.
	 *
	 */
	function "grid.revert.gPath"("x", "strict"="FALSE", "grep"="FALSE", "global"="FALSE", "redraw"="FALSE", "...")
	/**
	 * 
	 * Some grobs only generate their content to draw at
	 * drawing time;  this function replaces such grobs with
	 * their at-drawing-time content.
	 *
	 */
	function "grid.revert.grob"("x", "draw"="FALSE", "...")
	/**
	 * Draw a \emph{single} rectangle with rounded corners.
	 */
	exported function "grid.roundrect"("...")
	/**
	 * 
	 * These functions create and draw line segments.
	 *
	 */
	exported function "grid.segments"("x0"="unit(0, \"npc\")", "y0"="unit(0, \"npc\")", "x1"="unit(1, \"npc\")", "y1"="unit(1, \"npc\")", "default.units"="npc", "arrow"="", "name"="", "gp"="gpar()", "draw"="TRUE", "vp"="")
	/**
	 * 
	 * Replace a grob or a descendant of a grob.
	 *
	 *
	 */
	exported function "grid.set"("gPath", "newGrob", "strict"="FALSE", "grep"="FALSE", "redraw"="TRUE")
	/**
	 * 
	 * This function uses Grid graphics to draw a diagram of a
	 * Grid layout.
	 *
	 */
	exported function "grid.show.layout"("l", "newpage"="TRUE", "vp.ex"="0.8", "bg"="light grey", "cell.border"="blue", "cell.fill"="light blue", "cell.label"="TRUE", "label.col"="blue", "unit.col"="red", "vp"="")
	/**
	 * 
	 * This function uses Grid graphics to draw a diagram of
	 * a Grid viewport.
	 *
	 */
	exported function "grid.show.viewport"("v", "parent.layout"="", "newpage"="TRUE", "vp.ex"="0.8", "border.fill"="light grey", "vp.col"="blue", "vp.fill"="light blue", "scale.col"="red", "vp"="")
	/**
	 * 
	 * Internal Grid functions
	 *
	 */
	exported function "grid.strip"("label"="whatever", "range.full"="c(0, 1)", "range.thumb"="c(0.3, 0.6)", "fill"="#FFBF00", "thumb"="#FF8000", "vp"="")
	/**
	 * 
	 * These functions create and draw text and \link{plotmath} expressions.
	 *
	 */
	exported function "grid.text"("label", "x"="unit(0.5, \"npc\")", "y"="unit(0.5, \"npc\")", "just"="centre", "hjust"="", "vjust"="", "rot"="0", "check.overlap"="FALSE", "default.units"="npc", "name"="", "gp"="gpar()", "draw"="TRUE", "vp"="")
	function "grid.textMetric"("string")
	function "grid.top.level.vp"()
	/**
	 * 
	 * These functions create and draw an x-axis.
	 *
	 */
	exported function "grid.xaxis"("at"="", "label"="TRUE", "main"="TRUE", "edits"="", "name"="", "gp"="gpar()", "draw"="TRUE", "vp"="")
	/**
	 * 
	 * These functions create and draw an xspline, a curve drawn
	 * relative to control points.
	 *
	 */
	exported function "grid.xspline"("...")
	/**
	 * 
	 * These functions create and draw a y-axis.
	 *
	 */
	exported function "grid.yaxis"("at"="", "label"="TRUE", "main"="TRUE", "edits"="", "name"="", "gp"="gpar()", "draw"="TRUE", "vp"="")
	function "gridList"("x", "...")
	function "gridList.default"("x", "grobs"="TRUE", "viewports"="FALSE", "fullNames"="FALSE", "recursive"="TRUE")
	function "gridList.gList"("x", "grobs"="TRUE", "viewports"="FALSE", "fullNames"="FALSE", "recursive"="TRUE")
	function "gridList.grob"("x", "grobs"="TRUE", "viewports"="FALSE", "fullNames"="FALSE", "recursive"="TRUE")
	function "gridList.gTree"("x", "grobs"="TRUE", "viewports"="FALSE", "fullNames"="FALSE", "recursive"="TRUE")
	function "gridList.pop"("x", "grobs"="TRUE", "viewports"="FALSE", "fullNames"="FALSE", "recursive"="TRUE")
	function "gridList.up"("x", "grobs"="TRUE", "viewports"="FALSE", "fullNames"="FALSE", "recursive"="TRUE")
	function "gridList.viewport"("x", "grobs"="TRUE", "viewports"="FALSE", "fullNames"="FALSE", "recursive"="TRUE")
	function "gridList.vpList"("x", "grobs"="TRUE", "viewports"="FALSE", "fullNames"="FALSE", "recursive"="TRUE")
	function "gridList.vpPath"("x", "grobs"="TRUE", "viewports"="FALSE", "fullNames"="FALSE", "recursive"="TRUE")
	function "gridList.vpStack"("x", "grobs"="TRUE", "viewports"="FALSE", "fullNames"="FALSE", "recursive"="TRUE")
	function "gridList.vpTree"("x", "grobs"="TRUE", "viewports"="FALSE", "fullNames"="FALSE", "recursive"="TRUE")
	function "gridListDL"("x", "grobs"="TRUE", "viewports"="FALSE", "fullNames"="FALSE", "recursive"="TRUE")
	/**
	 * 
	 * Creating grid graphical objects, short (\dQuote{grob}s).
	 *
	 * \code{grob()} and \code{gTree()} are the basic creators,
	 * \code{grobTree()} and \code{gList()} take several grobs to build a new
	 * one.
	 *
	 */
	exported function "grob"("...", "name"="", "gp"="", "vp"="", "cl"="")
	/**
	 * 
	 * These functions create a unit object describing the width or height of
	 * a grob.  They are generic.
	 *
	 */
	exported function "grobAscent"("x")
	function "grobAscent.default"("x")
	function "grobAscent.gList"("x")
	function "grobAscent.gPath"("x")
	function "grobAscent.grob"("x")
	function "grobAutoName"("prefix"="GRID", "suffix"="GROB")
	/**
	 * 
	 * These functions create a unit object describing the width or height of
	 * a grob.  They are generic.
	 *
	 */
	exported function "grobDescent"("x")
	function "grobDescent.default"("x")
	function "grobDescent.gList"("x")
	function "grobDescent.gPath"("x")
	function "grobDescent.grob"("x")
	/**
	 * 
	 * These functions create a unit object describing the width or height of
	 * a grob.  They are generic.
	 *
	 */
	exported function "grobHeight"("x")
	function "grobHeight.default"("x")
	function "grobHeight.gList"("x")
	function "grobHeight.gPath"("x")
	function "grobHeight.grob"("x")
	function "grobLabel"("grob", "gp"="gpar(col = rgb(1, 0, 0, 0.5), fill = rgb(1, 0, 0, 0.2))", "...")
	/**
	 * 
	 * This function generates a unique (within-session) name for
	 * a grob, based on the grob's class.
	 *
	 */
	exported function "grobName"("grob"="", "prefix"="GRID")
	/**
	 * 
	 * Return a listing of the names of grobs or viewports.
	 *
	 * This is a generic function with methods for grobs (including
	 * gTrees) and viewports (including vpTrees).
	 *
	 */
	exported function "grobPathListing"("x", "...")
	/**
	 * 
	 * Creating grid graphical objects, short (\dQuote{grob}s).
	 *
	 * \code{grob()} and \code{gTree()} are the basic creators,
	 * \code{grobTree()} and \code{gList()} take several grobs to build a new
	 * one.
	 *
	 */
	exported function "grobTree"("...", "name"="", "gp"="", "vp"="", "childrenvp"="", "cl"="")
	function "grobUnit"("unit")
	/**
	 * 
	 * These functions create a unit object describing the width or height of
	 * a grob.  They are generic.
	 *
	 */
	exported function "grobWidth"("x")
	function "grobWidth.default"("x")
	function "grobWidth.gList"("x")
	function "grobWidth.gPath"("x")
	function "grobWidth.grob"("x")
	/**
	 * 
	 * These functions create a unit object describing a location somewhere
	 * on the boundary of
	 * a grob.  They are generic.
	 *
	 */
	exported function "grobX"("x", "theta")
	function "grobX.default"("x", "theta")
	function "grobX.gList"("x", "theta")
	function "grobX.gPath"("x", "theta")
	function "grobX.grob"("x", "theta")
	/**
	 * 
	 * These functions create a unit object describing a location somewhere
	 * on the boundary of
	 * a grob.  They are generic.
	 *
	 */
	exported function "grobY"("x", "theta")
	function "grobY.default"("x", "theta")
	function "grobY.gList"("x", "theta")
	function "grobY.gPath"("x", "theta")
	function "grobY.grob"("x", "theta")
	function "growPath"("pathsofar", "name")
	function "growResult"("result", "x")
	function "growResult.default"("result", "x")
	function "growResult.gList"("result", "x")
	function "growResult.grob"("result", "x")
	/**
	 * 
	 * Creating grid graphical objects, short (\dQuote{grob}s).
	 *
	 * \code{grob()} and \code{gTree()} are the basic creators,
	 * \code{grobTree()} and \code{gList()} take several grobs to build a new
	 * one.
	 *
	 */
	exported function "gTree"("...", "name"="", "gp"="", "vp"="", "children"="", "childrenvp"="", "cl"="")
	function "height"("x")
	function "height.details.viewport"("x")
	/**
	 * 
	 * These generic functions are used to determine the size of grid grobs.
	 *
	 */
	exported function "heightDetails"("x")
	function "heightDetails.arrows"("x")
	function "heightDetails.beziergrob"("x")
	function "heightDetails.cellGrob"("x")
	function "heightDetails.circle"("x")
	function "heightDetails.curve"("x")
	function "heightDetails.default"("x")
	function "heightDetails.frame"("x")
	function "heightDetails.functiongrob"("x")
	function "heightDetails.lines"("x")
	function "heightDetails.null"("x")
	function "heightDetails.pathgrob"("x")
	function "heightDetails.points"("x")
	function "heightDetails.polygon"("x")
	function "heightDetails.polyline"("x")
	function "heightDetails.rastergrob"("x")
	function "heightDetails.rect"("x")
	function "heightDetails.roundrect"("x")
	function "heightDetails.segments"("x")
	function "heightDetails.text"("x")
	function "heightDetails.xspline"("x")
	function "inc.display.list"()
	function "incDepth"("depth", "n"="1")
	function "incPath"("oldpath", "addition")
	function "initGrobAutoName"()
	function "initvpAutoName"()
	function "interleave"("ncp", "ncurve", "val", "sval", "eval", "e")
	function "is.even"("x")
	function "is.gEdit"("x")
	function "is.gEditList"("x")
	function "is.gList"("x")
	function "is.gpar"("x")
	/**
	 * 
	 * Creating grid graphical objects, short (\dQuote{grob}s).
	 *
	 * \code{grob()} and \code{gTree()} are the basic creators,
	 * \code{grobTree()} and \code{gList()} take several grobs to build a new
	 * one.
	 *
	 */
	exported function "is.grob"("x")
	function "is.layout"("l")
	function "is.odd"("x")
	/**
	 * 
	 * Internal Grid functions
	 *
	 */
	exported function "is.unit"("unit")
	function "is.unit.arithmetic"("x")
	function "is.unit.list"("x")
	function "is.viewport"("vp")
	var "L_arrows"
	var "L_cap"
	var "L_circle"
	var "L_circleBounds"
	var "L_clip"
	var "L_convert"
	var "L_currentGPar"
	var "L_currentViewport"
	var "L_downviewport"
	var "L_downvppath"
	var "L_getCurrentGrob"
	var "L_getDisplayList"
	var "L_getDLelt"
	var "L_getDLindex"
	var "L_getDLon"
	var "L_getEngineDLon"
	var "L_getEngineRecording"
	var "L_getGPar"
	var "L_gridDirty"
	var "L_initDisplayList"
	var "L_initGPar"
	var "L_initGrid"
	var "L_initViewportStack"
	var "L_killGrid"
	var "L_layoutRegion"
	var "L_lines"
	var "L_lineTo"
	var "L_locator"
	var "L_locnBounds"
	var "L_moveTo"
	var "L_newpage"
	var "L_newpagerecording"
	var "L_path"
	var "L_points"
	var "L_polygon"
	var "L_pretty"
	var "L_raster"
	var "L_rect"
	var "L_rectBounds"
	var "L_segments"
	var "L_setCurrentGrob"
	var "L_setDisplayList"
	var "L_setDLelt"
	var "L_setDLindex"
	var "L_setDLon"
	var "L_setEngineDLon"
	var "L_setEngineRecording"
	var "L_setGPar"
	var "L_setviewport"
	var "L_stringMetric"
	var "L_text"
	var "L_textBounds"
	var "L_unsetviewport"
	var "L_upviewport"
	var "L_xspline"
	var "L_xsplineBounds"
	var "L_xsplinePoints"
	function "labelGrob"("grob", "recurse", "curdepth", "depth", "labelfun", "...")
	function "labelGrob.grob"("grob", "recurse", "curdepth", "depth", "labelfun", "...")
	function "labelGrob.gTree"("grob", "recurse", "curdepth", "depth", "labelfun", "...")
	function "labelVP"("vp", "col")
	/**
	 * 
	 * Internal Grid functions
	 *
	 */
	exported function "layout.heights"("lay")
	function "layout.ncol"("lay")
	function "layout.nrow"("lay")
	function "layout.respect"("lay")
	/**
	 * 
	 * Internal Grid functions
	 *
	 */
	exported function "layout.torture"()
	/**
	 * 
	 * Internal Grid functions
	 *
	 */
	exported function "layout.widths"("lay")
	/**
	 * 
	 * Internal Grid functions
	 *
	 */
	exported function "layoutRegion"("layout.pos.row"="1", "layout.pos.col"="1")
	function "leafPaths"("vp")
	function "leafPaths.viewport"("vp")
	function "leafPaths.vpList"("vp")
	function "leafPaths.vpPath"("vp")
	function "leafPaths.vpStack"("vp")
	function "leafPaths.vpTree"("vp")
	/**
	 * 
	 * Constructing a legend grob (in progress)
	 *
	 */
	exported function "legendGrob"("labels", "nrow", "ncol", "byrow"="FALSE", "do.lines"="has.lty || has.lwd", "lines.first"="TRUE", "hgap"="unit(1, \"lines\")", "vgap"="unit(1, \"lines\")", "default.units"="lines", "pch", "gp"="gpar()", "vp"="")
	function "length.arrow"("x")
	function "length.unit"("x")
	function "length.unit.arithmetic"("x")
	function "length.unit.list"("x")
	/**
	 * 
	 * These functions create and draw a series of lines.
	 *
	 */
	exported function "linesGrob"("x"="unit(c(0, 1), \"npc\")", "y"="unit(c(0, 1), \"npc\")", "default.units"="npc", "arrow"="", "name"="", "gp"="gpar()", "vp"="")
	/**
	 * 
	 * Grid has the notion of a current location.  These functions
	 * sets that location.
	 *
	 */
	exported function "lineToGrob"("x"="1", "y"="1", "default.units"="npc", "arrow"="", "name"="", "gp"="gpar()", "vp"="")
	function "listvpListElement"("x", "...")
	function "make.xaxis.labels"("at", "label", "main")
	function "make.xaxis.major"("at", "main")
	function "make.xaxis.ticks"("at", "main")
	function "make.yaxis.labels"("at", "label", "main")
	function "make.yaxis.major"("at", "main")
	function "make.yaxis.ticks"("at", "main")
	/**
	 * 
	 * These generic hook functions are called whenever a grid grob is drawn.
	 * They provide an opportunity for customising the drawing context
	 * and drawing content of a
	 * new class derived from grob (or gTree).
	 *
	 */
	exported function "makeContent"("x")
	function "makeContent.beziergrob"("x")
	function "makeContent.curve"("x")
	function "makeContent.default"("x")
	function "makeContent.delayedgrob"("x")
	function "makeContent.forcedgrob"("x")
	function "makeContent.functiongrob"("x")
	function "makeContent.roundrect"("x")
	function "makeContent.xaxis"("x")
	function "makeContent.yaxis"("x")
	/**
	 * 
	 * These generic hook functions are called whenever a grid grob is drawn.
	 * They provide an opportunity for customising the drawing context
	 * and drawing content of a
	 * new class derived from grob (or gTree).
	 *
	 */
	exported function "makeContext"("x")
	function "makeContext.cellGrob"("x")
	function "makeContext.default"("x")
	function "makeContext.forcedgrob"("x")
	function "makeContext.frame"("x")
	function "makeContext.roundrect"("x")
	var "Mb"
	function "mod.dims"("dim", "dims", "index", "new.index", "nindex", "force")
	function "mod.gpar"("gp", "newgp")
	/**
	 * 
	 * Grid has the notion of a current location.  These functions
	 * sets that location.
	 *
	 */
	exported function "moveToGrob"("x"="0", "y"="0", "default.units"="npc", "name"="", "vp"="")
	var "Ms"
	var "Msinv"
	function "nameMatch"("pathName", "grobName", "grep")
	function "namePos"("pathName", "names", "grep")
	/**
	 * 
	 * Return a listing of the names of grobs or viewports.
	 *
	 * This is a generic function with methods for grobs (including
	 * gTrees) and viewports (including vpTrees).
	 *
	 */
	exported function "nestedListing"("x", "gindent"="  ", "vpindent")
	function "new.col"("side", "col", "col.before", "col.after", "ncol")
	function "new.row"("side", "row", "row.before", "row.after", "nrow")
	function "no.children"("children")
	/**
	 * 
	 * These functions create a NULL graphical object,
	 * which has zero width, zero height, and draw nothing.
	 * It can be used as a place-holder or as an invisible
	 * reference point for other drawing.
	 *
	 */
	exported function "nullGrob"("x"="unit(0.5, \"npc\")", "y"="unit(0.5, \"npc\")", "default.units"="npc", "name"="", "vp"="")
	function "num.col.specs"("side", "col", "col.before", "col.after")
	function "num.row.specs"("side", "row", "row.before", "row.after")
	function "okGListelt"("x")
	function "OLDflatListing.vpTreeListing"("x", "gDepth"="0", "vpDepth"="0", "gPath"="", "vpPath"="")
	function "Ops.unit"("e1", "e2")
	function "origin.bottom"("origin")
	function "origin.left"("origin")
	function "origin.right"("origin")
	function "origin.top"("origin")
	/**
	 * 
	 * these functions, together with \code{grid.frame} and \code{frameGrob}
	 * are part of a
	 * GUI-builder-like interface to constructing graphical images.
	 * The idea is that you create a frame with \code{grid.frame} or
	 * \code{frameGrob} then
	 * use these functions to pack objects into the frame.
	 *
	 */
	exported function "packGrob"("frame", "grob", "side"="", "row"="", "row.before"="", "row.after"="", "col"="", "col.before"="", "col.after"="", "width"="", "height"="", "force.width"="FALSE", "force.height"="FALSE", "border"="", "dynamic"="FALSE")
	function "partialPathMatch"("pathsofar", "path", "strict"="FALSE", "grep")
	/**
	 * 
	 * These functions create and draw a path.
	 * The final point will automatically
	 * be connected to the initial point.
	 *
	 */
	exported function "pathGrob"("x", "y", "id"="", "id.lengths"="", "rule"="winding", "default.units"="npc", "name"="", "gp"="gpar()", "vp"="")
	/**
	 * 
	 * Return a listing of the names of grobs or viewports.
	 *
	 * This is a generic function with methods for grobs (including
	 * gTrees) and viewports (including vpTrees).
	 *
	 */
	exported function "pathListing"("x", "gvpSep"=" | ", "gAlign"="TRUE")
	function "pathMatch"("path", "pathsofar", "strict")
	/**
	 * 
	 * These functions provide a simpler (and faster) alternative
	 * to the \code{grid.pack()} and \code{packGrob}
	 * functions.  They can be used to place objects within the existing
	 * rows and columns of a frame layout.  They do not provide the ability to
	 * add new rows and columns nor do they affect the
	 * heights and widths of the rows and columns.
	 *
	 */
	exported function "placeGrob"("frame", "grob", "row"="", "col"="")
	/**
	 * 
	 * This is a convenience function for producing a viewport with
	 * the common S-style plot layout -- i.e., a central
	 * plot region surrounded by margins given in terms of a
	 * number of lines of text.
	 *
	 */
	exported function "plotViewport"("margins"="c(5.1, 4.1, 4.1, 2.1)", "...")
	/**
	 * 
	 * These functions create and draw data symbols.
	 *
	 */
	exported function "pointsGrob"("x"="stats::runif(10)", "y"="stats::runif(10)", "pch"="1", "size"="unit(1, \"char\")", "default.units"="native", "name"="", "gp"="gpar()", "vp"="")
	/**
	 * 
	 * These functions create and draw a polygon.
	 * The final point will automatically
	 * be connected to the initial point.
	 *
	 */
	exported function "polygonGrob"("x"="c(0, 0.5, 1, 0.5)", "y"="c(0.5, 1, 0.5, 0)", "id"="", "id.lengths"="", "default.units"="npc", "name"="", "gp"="gpar()", "vp"="")
	/**
	 * 
	 * These functions create and draw a series of lines.
	 *
	 */
	exported function "polylineGrob"("x"="unit(c(0, 1), \"npc\")", "y"="unit(c(0, 1), \"npc\")", "id"="", "id.lengths"="", "default.units"="npc", "arrow"="", "name"="", "gp"="gpar()", "vp"="")
	/**
	 * 
	 * The functions or variables listed here are no longer part of \pkg{grid}.
	 *
	 */
	exported function "pop.viewport"("n"="1", "recording"="TRUE")
	function "popgrobvp"("vp")
	function "popgrobvp.viewport"("vp")
	function "popgrobvp.vpPath"("vp")
	/**
	 * 
	 * Grid maintains a tree of viewports --- nested drawing
	 * contexts.
	 *
	 * These functions provide ways to add or remove viewports
	 * and to navigate amongst viewports in the tree.
	 *
	 */
	exported function "popViewport"("n"="1", "recording"="TRUE")
	function "postDraw"("x")
	function "postDraw.grob"("x")
	/**
	 * 
	 * These generic hook functions are called whenever a grid grob is drawn.
	 * They provide an opportunity for customising the drawing of a
	 * new class derived from grob (or gTree).
	 *
	 */
	exported function "postDrawDetails"("x")
	function "postDrawDetails.grob"("x")
	function "preDraw"("x")
	function "preDraw.grob"("x")
	function "preDraw.gTree"("x")
	/**
	 * 
	 * These generic hook functions are called whenever a grid grob is drawn.
	 * They provide an opportunity for customising the drawing of a
	 * new class derived from grob (or gTree).
	 *
	 */
	exported function "preDrawDetails"("x")
	function "preDrawDetails.grob"("x")
	function "print.flatGridListing"("x", "...")
	function "print.gList"("x", "...")
	function "print.gpar"("x", "...")
	function "print.grob"("x", "...")
	function "print.path"("x", "...")
	function "print.unit"("x", "...")
	function "print.viewport"("x", "...")
	/**
	 * 
	 * The functions or variables listed here are no longer part of \pkg{grid}.
	 *
	 */
	exported function "push.viewport"("...", "recording"="TRUE")
	function "push.vp"("vp", "recording")
	function "push.vp.default"("vp", "recording")
	function "push.vp.viewport"("vp", "recording")
	function "push.vp.vpList"("vp", "recording")
	function "push.vp.vpPath"("vp", "recording")
	function "push.vp.vpStack"("vp", "recording")
	function "push.vp.vpTree"("vp", "recording")
	function "pushedvp"("vp")
	function "pushgrobvp"("vp")
	function "pushgrobvp.viewport"("vp")
	function "pushgrobvp.vpPath"("vp")
	/**
	 * 
	 * Grid maintains a tree of viewports --- nested drawing
	 * contexts.
	 *
	 * These functions provide ways to add or remove viewports
	 * and to navigate amongst viewports in the tree.
	 *
	 */
	exported function "pushViewport"("...", "recording"="TRUE")
	function "pushvpgp"("x")
	/**
	 * 
	 * Render a raster object (bitmap image) at the given location, size,
	 * and orientation.
	 *
	 */
	exported function "rasterGrob"("image", "x"="unit(0.5, \"npc\")", "y"="unit(0.5, \"npc\")", "width"="", "height"="", "just"="centre", "hjust"="", "vjust"="", "interpolate"="TRUE", "default.units"="npc", "name"="", "gp"="gpar()", "vp"="")
	function "record"("x")
	function "record.default"("x")
	function "record.grob"("x")
	function "record.viewport"("x")
	function "record.vpPath"("x")
	/**
	 * 
	 * Evaluates an expression that includes both calculations
	 * and drawing that depends on the calculations so that
	 * both the calculations and the drawing will be rerun when
	 * the scene is redrawn (e.g., device resize or editing).
	 *
	 * Intended \emph{only} for expert use.
	 *
	 */
	function "recordGrob"("expr", "list", "name"="", "gp"="", "vp"="")
	/**
	 * 
	 * These functions create and draw rectangles.
	 *
	 */
	exported function "rectGrob"("x"="unit(0.5, \"npc\")", "y"="unit(0.5, \"npc\")", "width"="unit(1, \"npc\")", "height"="unit(1, \"npc\")", "just"="centre", "hjust"="", "vjust"="", "default.units"="npc", "name"="", "gp"="gpar()", "vp"="")
	function "recycle.data"("data", "data.per", "max.n", "units")
	function "removeDLFromGPath"("gPath", "name", "strict", "grep", "grepname", "global", "warn", "redraw")
	function "removeFromGTree"("gTree", "name", "grep")
	/**
	 * 
	 * Remove a grob from a gTree or a descendant of a gTree.
	 *
	 */
	exported function "removeGrob"("gTree", "gPath", "strict"="FALSE", "grep"="FALSE", "global"="FALSE", "warn"="TRUE")
	function "removeGrobFromGPath"("grob", "name", "pathsofar", "gPath", "strict", "grep", "grepname", "global", "warn")
	function "removeGrobFromGPath.default"("grob", "name", "pathsofar", "gPath", "strict", "grep", "grepname", "global", "warn")
	function "removeGrobFromGPath.grob"("grob", "name", "pathsofar", "gPath", "strict", "grep", "grepname", "global", "warn")
	function "removeGrobFromGPath.gTree"("grob", "name", "pathsofar", "gPath", "strict", "grep", "grepname", "global", "warn")
	function "removeGrobFromName"("grob", "name", "grep", "global", "warn")
	function "removeGrobFromName.grob"("grob", "name", "grep", "global", "warn")
	function "removeGrobFromName.gTree"("grob", "name", "grep", "global", "warn")
	function "removeGTree"("gTree", "name", "pathsofar", "gPath", "strict", "grep", "grepname", "global", "warn")
	function "removeName"("gTree", "name", "strict", "grep", "global", "warn")
	function "removeNameFromDL"("name", "strict", "grep", "global", "warn", "redraw")
	/**
	 * 
	 * Change the order in which the children of a gTree get drawn.
	 *
	 */
	exported function "reorderGrob"("x", "order", "back"="TRUE")
	function "rep.arrow"("x", "...")
	function "rep.unit"("x", "times"="1", "length.out"="NA", "each"="1", "...")
	/**
	 * 
	 * Utility functions for determining
	 * whether a justification specification is valid
	 * and for resolving a single justification value from
	 * a combination of character and numeric values.
	 *
	 */
	exported function "resolveHJust"("just", "hjust")
	/**
	 * 
	 * Determine the width and height of a raster grob when one or both
	 * are not given explicitly.
	 *
	 * The result depends on both the aspect ratio of the raster image
	 * and the aspect ratio of the physical drawing context, so the
	 * result is only valid for the drawing context in which this
	 * function is called.
	 *
	 */
	exported function "resolveRasterSize"("x")
	/**
	 * 
	 * Utility functions for determining
	 * whether a justification specification is valid
	 * and for resolving a single justification value from
	 * a combination of character and numeric values.
	 *
	 */
	exported function "resolveVJust"("just", "vjust")
	function "revert"("x")
	function "revert.default"("x")
	function "revert.forcedgrob"("x")
	function "rootVP"("pvp")
	function "roundCorner"("num", "x", "y", "r")
	/**
	 * Draw a \emph{single} rectangle with rounded corners.
	 */
	exported function "roundrectGrob"("x"="0.5", "y"="0.5", "width"="1", "height"="1", "default.units"="npc", "r"="unit(0.1, \"snpc\")", "just"="centre", "name"="", "gp"="", "vp"="")
	function "row.spec"("side", "row", "row.before", "row.after", "nrow")
	function "rrpoints"("x")
	/**
	 * 
	 * Grid maintains a tree of viewports --- nested drawing
	 * contexts.
	 *
	 * These functions provide ways to add or remove viewports
	 * and to navigate amongst viewports in the tree.
	 *
	 */
	exported function "seekViewport"("name", "recording"="TRUE")
	function "segmentBounds"("x", "theta")
	/**
	 * 
	 * These functions create and draw line segments.
	 *
	 */
	exported function "segmentsGrob"("x0"="unit(0, \"npc\")", "y0"="unit(0, \"npc\")", "x1"="unit(1, \"npc\")", "y1"="unit(1, \"npc\")", "default.units"="npc", "arrow"="", "name"="", "gp"="gpar()", "vp"="")
	function "set.gpar"("gp")
	/**
	 * 
	 * Add a grob to a gTree or a descendant of a gTree.
	 *
	 */
	exported function "setChildren"("x", "children")
	function "setDLfromGPath"("gPath", "newGrob", "strict", "grep")
	/**
	 * 
	 * Replace a grob or a descendant of a grob.
	 *
	 *
	 */
	exported function "setGrob"("gTree", "gPath", "newGrob", "strict"="FALSE", "grep"="FALSE")
	function "setGrobFromGPath"("grob", "pathsofar", "gPath", "newGrob", "strict", "grep")
	function "setGrobFromGPath.default"("grob", "pathsofar", "gPath", "newGrob", "strict", "grep")
	function "setGrobFromGPath.grob"("grob", "pathsofar", "gPath", "newGrob", "strict", "grep")
	function "setGrobFromGPath.gTree"("grob", "pathsofar", "gPath", "newGrob", "strict", "grep")
	function "setGTree"("gTree", "pathsofar", "gPath", "newGrob", "strict", "grep")
	function "setvpgpar"("vp")
	function "setvpgpar.viewport"("vp")
	function "setvpgpar.vpList"("vp")
	function "setvpgpar.vpStack"("vp")
	function "setvpgpar.vpTree"("vp")
	/**
	 * 
	 * Produces a graphical display of (by default) the current grid scene,
	 * with labels showing the names of each grob in the scene.
	 * It is also possible to label only specific grobs in the scene.
	 *
	 */
	exported function "showGrob"("x"="", "gPath"="", "strict"="FALSE", "grep"="FALSE", "recurse"="TRUE", "depth"="", "labelfun", "...")
	/**
	 * 
	 * Produces a graphical display of (by default) the current
	 * grid viewport tree.  It is also possible to display only
	 * specific viewports.  Each viewport is drawn as a rectangle
	 * and the leaf viewports are labelled with the viewport name.
	 *
	 */
	exported function "showViewport"("vp"="", "recurse"="TRUE", "depth"="", "newpage"="FALSE", "leaves"="FALSE", "col"="rgb(0, 0, 1, 0.2)", "fill"="rgb(0, 0, 1, 0.1)", "label"="TRUE", "nrow"="3", "ncol")
	function "showVP"("vp", "newpage", "cvpt", "depth", "col", "fill", "label")
	function "showVPmatrix"("vp", "cvpt", "depth", "col", "fill", "label", "nrow", "ncol")
	function "splinegrob"("x")
	function "splinePoints"("xb", "yb", "idIndex")
	function "STATE"()
	function "str.unit.arithmetic"("object", "...")
	function "straightCurve"("x1", "y1", "x2", "y2", "arrow", "debug")
	/**
	 * 
	 * These functions create a unit object describing the width or height of
	 * a string.
	 *
	 */
	exported function "stringAscent"("string")
	/**
	 * 
	 * These functions create a unit object describing the width or height of
	 * a string.
	 *
	 */
	exported function "stringDescent"("string")
	/**
	 * 
	 * These functions create a unit object describing the width or height of
	 * a string.
	 *
	 */
	exported function "stringHeight"("string")
	function "stringUnit"("unit")
	/**
	 * 
	 * These functions create a unit object describing the width or height of
	 * a string.
	 *
	 */
	exported function "stringWidth"("string")
	function "Summary.unit"("...", "na.rm"="FALSE")
	function "swap.origin.horizontal"("origin")
	function "swap.origin.vertical"("origin")
	function "tests"()
	/**
	 * 
	 * These functions create and draw text and \link{plotmath} expressions.
	 *
	 */
	exported function "textGrob"("label", "x"="unit(0.5, \"npc\")", "y"="unit(0.5, \"npc\")", "just"="centre", "hjust"="", "vjust"="", "rot"="0", "check.overlap"="FALSE", "default.units"="npc", "name"="", "gp"="gpar()", "vp"="")
	/**
	 * 
	 * This function creates a unit object --- a vector of unit values.
	 * A unit value is typically just a single numeric value with an
	 * associated unit.
	 *
	 */
	exported function "unit"("x", "units", "data"="")
	function "unit.arithmetic"("func.name", "arg1", "arg2"="")
	/**
	 * 
	 * This function produces a new unit object by combining the
	 * unit objects specified as arguments.
	 *
	 */
	exported function "unit.c"("...")
	/**
	 * 
	 * The length of a unit object is defined as the number of unit
	 * values in the unit object.
	 *
	 * This function has been deprecated in favour of a unit method for
	 * the generic \code{length} function.
	 *
	 */
	exported function "unit.length"("unit")
	function "unit.list"("unit")
	function "unit.list.from.list"("x")
	/**
	 * 
	 * Returns a unit object whose i'th value is the minimum (or maximum)
	 * of the i'th values of the arguments.
	 *
	 */
	exported function "unit.pmax"("...")
	/**
	 * 
	 * Returns a unit object whose i'th value is the minimum (or maximum)
	 * of the i'th values of the arguments.
	 *
	 */
	exported function "unit.pmin"("...")
	/**
	 * 
	 * Replicates the units according to the values given in \code{times} and
	 * \code{length.out}.
	 *
	 * This function has been deprecated in favour of a unit method for
	 * the generic \code{rep} function.
	 *
	 */
	exported function "unit.rep"("x", "...")
	function "updateCol"("col", "added.col")
	function "updateGDepth"("x", "gdepth")
	function "updateGDepth.default"("x", "gdepth")
	function "updateGPath"("x", "gpath")
	function "updateGPath.default"("x", "gpath")
	function "updateRow"("row", "added.row")
	function "updateVPDepth"("x", "vpdepth")
	function "updateVPDepth.default"("x", "vpdepth")
	function "updateVPDepth.vpListing"("x", "vpdepth")
	function "updateVPDepth.vpListListing"("x", "vpdepth")
	function "updateVPDepth.vpNameListing"("x", "vpdepth")
	function "updateVPDepth.vpPopListing"("x", "vpdepth")
	function "updateVPDepth.vpTreeListing"("x", "vpdepth")
	function "updateVPDepth.vpUpListing"("x", "vpdepth")
	function "updateVPPath"("x", "vppath")
	function "updateVPPath.default"("x", "vppath")
	function "updateVPPath.vpListing"("x", "vppath")
	function "updateVPPath.vpListListing"("x", "vppath")
	function "updateVPPath.vpNameListing"("x", "vppath")
	function "updateVPPath.vpPopListing"("x", "vppath")
	function "updateVPPath.vpTreeListing"("x", "vppath")
	function "updateVPPath.vpUpListing"("x", "vppath")
	function "updateXlabels"("x")
	function "updateYlabels"("x")
	/**
	 * 
	 * Grid maintains a tree of viewports --- nested drawing
	 * contexts.
	 *
	 * These functions provide ways to add or remove viewports
	 * and to navigate amongst viewports in the tree.
	 *
	 */
	exported function "upViewport"("n"="1", "recording"="TRUE")
	function "valid.charjust"("just")
	function "valid.data"("units", "data")
	/**
	 * 
	 * Utility functions for determining
	 * whether a justification specification is valid
	 * and for resolving a single justification value from
	 * a combination of character and numeric values.
	 *
	 */
	exported function "valid.just"("just")
	function "valid.layout"("nrow", "ncol", "widths", "heights", "respect", "just")
	function "valid.numjust"("just")
	function "valid.origin"("origin")
	function "valid.pch"("pch")
	function "valid.unit"("x", "units", "data")
	function "valid.units"("units")
	function "valid.viewport"("x", "y", "width", "height", "just", "gp", "clip", "xscale", "yscale", "angle", "layout", "layout.pos.row", "layout.pos.col", "name")
	/**
	 * 
	 * This generic hook function is called whenever a grid grob is created
	 * or
	 * edited
	 * via \code{grob}, \code{gTree}, \code{grid.edit} or \code{editGrob}.
	 * This provides an opportunity for customising the validation of a
	 * new class derived from grob (or gTree).
	 *
	 */
	exported function "validDetails"("x")
	function "validDetails.arrows"("x")
	function "validDetails.axis"("x")
	function "validDetails.beziergrob"("x")
	function "validDetails.circle"("x")
	function "validDetails.clip"("x")
	function "validDetails.curve"("x")
	function "validDetails.functiongrob"("x", "...")
	function "validDetails.grob"("x")
	function "validDetails.line.to"("x")
	function "validDetails.lines"("x")
	function "validDetails.move.to"("x")
	function "validDetails.null"("x")
	function "validDetails.pathgrob"("x")
	function "validDetails.points"("x")
	function "validDetails.polygon"("x")
	function "validDetails.polyline"("x")
	function "validDetails.rastergrob"("x")
	function "validDetails.rect"("x")
	function "validDetails.roundrect"("x")
	function "validDetails.segments"("x")
	function "validDetails.text"("x")
	function "validDetails.xspline"("x")
	function "validGP"("gpars")
	function "validGrob"("x", "...")
	function "validGrob.grob"("x", "...")
	function "validGrob.gTree"("x", "childrenvp", "...")
	var "validUnits"
	/**
	 * 
	 * These functions create viewports, which describe rectangular regions
	 * on a graphics device and define a number of coordinate systems within
	 * those regions.
	 *
	 */
	exported function "viewport"("x"="unit(0.5, \"npc\")", "y"="unit(0.5, \"npc\")", "width"="unit(1, \"npc\")", "height"="unit(1, \"npc\")", "default.units"="npc", "just"="centre", "gp"="gpar()", "clip"="inherit", "xscale"="c(0, 1)", "yscale"="c(0, 1)", "angle"="0", "layout"="", "layout.pos.row"="", "layout.pos.col"="", "name"="")
	/**
	 * 
	 * Internal Grid functions
	 *
	 */
	exported function "viewport.layout"("vp")
	/**
	 * 
	 * The functions or variables listed here are no longer part of \pkg{grid}.
	 *
	 */
	exported function "viewport.transform"("vp")
	function "viewportorpath"("x")
	function "vpAutoName"()
	function "vpDepth"()
	function "vpExists"("vp")
	function "vpExists.viewport"("vp")
	function "vpExists.vpList"("vp")
	function "vpExists.vpPath"("vp")
	function "vpExists.vpStack"("vp")
	function "vpExists.vpTree"("vp")
	function "vpFromPushedvp"("pvp")
	/**
	 * 
	 * These functions create viewports, which describe rectangular regions
	 * on a graphics device and define a number of coordinate systems within
	 * those regions.
	 *
	 */
	exported function "vpList"("...")
	function "vpListFromList"("vps")
	function "vpListFromNode"("node")
	/**
	 * 
	 * This function can be used to generate a viewport path for use
	 * in \code{downViewport} or \code{seekViewport}.
	 *
	 * A viewport path is a list of nested viewport names.
	 *
	 */
	exported function "vpPath"("...")
	function "vpPathFromVector"("names")
	/**
	 * 
	 * These functions create viewports, which describe rectangular regions
	 * on a graphics device and define a number of coordinate systems within
	 * those regions.
	 *
	 */
	exported function "vpStack"("...")
	/**
	 * 
	 * These functions create viewports, which describe rectangular regions
	 * on a graphics device and define a number of coordinate systems within
	 * those regions.
	 *
	 */
	exported function "vpTree"("parent", "children")
	function "vpTreeFromNode"("node")
	function "width"("x")
	function "width.details.viewport"("x")
	/**
	 * 
	 * These generic functions are used to determine the size of grid grobs.
	 *
	 */
	exported function "widthDetails"("x")
	function "widthDetails.arrows"("x")
	function "widthDetails.beziergrob"("x")
	function "widthDetails.cellGrob"("x")
	function "widthDetails.circle"("x")
	function "widthDetails.curve"("x")
	function "widthDetails.default"("x")
	function "widthDetails.frame"("x")
	function "widthDetails.functiongrob"("x")
	function "widthDetails.lines"("x")
	function "widthDetails.null"("x")
	function "widthDetails.pathgrob"("x")
	function "widthDetails.points"("x")
	function "widthDetails.polygon"("x")
	function "widthDetails.polyline"("x")
	function "widthDetails.rastergrob"("x")
	function "widthDetails.rect"("x")
	function "widthDetails.roundrect"("x")
	function "widthDetails.segments"("x")
	function "widthDetails.text"("x")
	function "widthDetails.xspline"("x")
	function "wrap"("x")
	function "wrap.default"("x")
	function "wrap.grob"("x")
	function "wrap.pop"("x")
	function "wrap.up"("x")
	function "wrap.viewport"("x")
	function "wrap.vpPath"("x")
	/**
	 * 
	 * These functions create and draw an x-axis.
	 *
	 */
	exported function "xaxisGrob"("at"="", "label"="TRUE", "main"="TRUE", "edits"="", "name"="", "gp"="gpar()", "vp"="")
	/**
	 * 
	 * These generic functions are used to determine a location
	 * on the boundary of a grid grob.
	 *
	 */
	exported function "xDetails"("x", "theta")
	function "xDetails.beziergrob"("x", "theta")
	function "xDetails.circle"("x", "theta")
	function "xDetails.curve"("x", "theta")
	function "xDetails.default"("x", "theta")
	function "xDetails.functiongrob"("x", "theta")
	function "xDetails.lines"("x", "theta")
	function "xDetails.null"("x", "theta")
	function "xDetails.pathgrob"("x", "theta")
	function "xDetails.points"("x", "theta")
	function "xDetails.polygon"("x", "theta")
	function "xDetails.polyline"("x", "theta")
	function "xDetails.rastergrob"("x", "theta")
	function "xDetails.rect"("x", "theta")
	function "xDetails.roundrect"("x", "theta")
	function "xDetails.segments"("x", "theta")
	function "xDetails.text"("x", "theta")
	function "xDetails.xspline"("x", "theta")
	/**
	 * 
	 * These functions create and draw an xspline, a curve drawn
	 * relative to control points.
	 *
	 */
	exported function "xsplineGrob"("x"="c(0, 0.5, 1, 0.5)", "y"="c(0.5, 1, 0.5, 0)", "id"="", "id.lengths"="", "default.units"="npc", "shape"="0", "open"="TRUE", "arrow"="", "repEnds"="TRUE", "name"="", "gp"="gpar()", "vp"="")
	function "xsplineIndex"("x")
	/**
	 * 
	 * Rather than drawing an Xspline (or Bezier curve), this function returns
	 * the points that would be used to draw the series of line
	 * segments for the Xspline.  This may be useful to post-process
	 * the Xspline curve, for example, to clip the curve.
	 *
	 */
	exported function "xsplinePoints"("x")
	/**
	 * 
	 * These functions create and draw a y-axis.
	 *
	 */
	exported function "yaxisGrob"("at"="", "label"="TRUE", "main"="TRUE", "edits"="", "name"="", "gp"="gpar()", "vp"="")
	/**
	 * 
	 * These generic functions are used to determine a location
	 * on the boundary of a grid grob.
	 *
	 */
	exported function "yDetails"("x", "theta")
	function "yDetails.beziergrob"("x", "theta")
	function "yDetails.circle"("x", "theta")
	function "yDetails.curve"("x", "theta")
	function "yDetails.default"("x", "theta")
	function "yDetails.functiongrob"("x", "theta")
	function "yDetails.lines"("x", "theta")
	function "yDetails.null"("x", "theta")
	function "yDetails.pathgrob"("x", "theta")
	function "yDetails.points"("x", "theta")
	function "yDetails.polygon"("x", "theta")
	function "yDetails.polyline"("x", "theta")
	function "yDetails.rastergrob"("x", "theta")
	function "yDetails.rect"("x", "theta")
	function "yDetails.roundrect"("x", "theta")
	function "yDetails.segments"("x", "theta")
	function "yDetails.text"("x", "theta")
	function "yDetails.xspline"("x", "theta")
}
