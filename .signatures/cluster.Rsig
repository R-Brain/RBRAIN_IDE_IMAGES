package "cluster" "2.0.4" {
	var ".__NAMESPACE__."
	var ".__S3MethodsTable__."
	var ".noGenerics"
	function ".onUnload"("libpath")
	var ".packageName"
	function ".print.fanny"("x", "digits"="getOption(\"digits\")", "...")
	function ".print.pam"("x", "...")
	/**
	 * 
	 * Computes agglomerative hierarchical clustering of the dataset.
	 *
	 */
	exported function "agnes"("x", "diss"="inherits(x, \"dist\")", "metric"="euclidean", "stand"="FALSE", "method"="average", "par.method", "keep.diss"="n < 100", "keep.data"="!diss", "trace.lev"="0")
	function "as.dendrogram.twins"("object", "...")
	function "as.membership"("clustering", "keep.names"="TRUE")
	/**
	 * 
	 * Draws a \dQuote{banner}, i.e. basically a horizontal \code{\link{barplot}}
	 * visualizing the (agglomerative or divisive) hierarchical clustering or
	 * an other binary dendrogram structure.
	 *
	 */
	exported function "bannerplot"("x", "w"="rev(x$height)", "fromLeft"="TRUE", "main"="", "sub"="", "xlab"="Height", "adj"="0", "col"="c(2, 0)", "border"="0", "axes"="TRUE", "frame.plot", "rev.xax"="!fromLeft", "xax.pretty"="TRUE", "labels"="", "nmax.lab"="35", "max.strlen"="5", "yax.do"="axes && length(x$order) <= nmax.lab", "yaxRight", "y.mar"="2.4 + max.strlen/2.5", "...")
	var "cl_clara"
	var "cl_daisy"
	var "cl_fanny"
	var "cl_mona"
	var "cl_pam"
	var "cl_Pam"
	var "cl_sweep"
	/**
	 * 
	 * Computes a \code{"clara"} object, a list representing a clustering of
	 * the data into \code{k} clusters.
	 *
	 */
	exported function "clara"("x", "k", "metric"="euclidean", "stand"="FALSE", "samples"="5", "sampsize"="min(n, 40 + 2 * k)", "trace"="0", "medoids.x"="TRUE", "keep.data", "rngR"="FALSE", "pamLike"="FALSE", "correct.d"="TRUE")
	/**
	 * 
	 * \code{clusGap()} calculates a goodness of clustering measure, the
	 * \dQuote{gap} statistic.  For each number of clusters \eqn{{k}}, it
	 * compares \eqn{{\log(W(k))}{log(W(k))}} with
	 * \eqn{{E^*[\log(W(k))]}{E*[log(W(k))]}} where the latter is defined via
	 * bootstrapping, i.e., simulating from a reference distribution (a
	 * uniform distribution on the hypercube determined by the ranges of the first centered,
	 * and then \code{\link{svd}}-rotated \code{x}).
	 *
	 * \code{maxSE(f, SE.f)} determines the location of the \bold{maximum}
	 * of \code{f}, taking a \dQuote{1-SE rule} into account for the
	 * \code{*SE*} methods.  The default method \code{"firstSEmax"} looks for
	 * the smallest \eqn{{k}} such that its value \eqn{{f(k)}} is not more than 1
	 * standard error away from the first local maximum.
	 * This is similar but not the same as \code{"Tibs2001SEmax"}, Tibshirani
	 * et al's recommendation of determining the number of clusters from the
	 * gap statistics and their standard deviations.
	 *
	 */
	exported function "clusGap"("x", "FUNcluster", "K.max", "B"="100", "d.power"="1", "verbose"="interactive()", "...")
	/**
	 * 
	 * Draws a 2-dimensional \dQuote{clusplot} (clustering plot) on the
	 * current graphics device.
	 * The generic function has a default and a \code{partition} method.
	 *
	 */
	exported function "clusplot"("x", "...")
	/**
	 * 
	 * Creates a bivariate plot visualizing a partition (clustering) of the data. All
	 * observation are represented by points in the plot, using principal
	 * components or multidimensional scaling. Around each cluster an ellipse
	 * is drawn.
	 *
	 */
	function "clusplot.default"("x", "clus", "diss"="FALSE", "s.x.2d"="mkCheckX(x, diss)", "stand"="FALSE", "lines"="2", "shade"="FALSE", "color"="FALSE", "labels"="0", "plotchar"="TRUE", "col.p"="dark green", "col.txt", "col.clus"="if (color) c(2, 4, 6, 3) else 5", "cex"="1", "cex.txt", "span"="TRUE", "add"="FALSE", "xlim"="", "ylim"="", "main"="paste(\"CLUSPLOT(\", deparse(substitute(x)), \")\")", "sub"="paste(\"These two components explain\", round(100 * var.dec, digits = 2),     \"% of the point variability.\")", "xlab"="Component 1", "ylab"="Component 2", "verbose"="getOption(\"verbose\")", "...")
	/**
	 * 
	 * Draws a 2-dimensional \dQuote{clusplot} (clustering plot) on the
	 * current graphics device.
	 * The generic function has a default and a \code{partition} method.
	 *
	 */
	function "clusplot.partition"("x", "main"="", "dist"="", "...")
	/**
	 * 
	 * Computes the \dQuote{agglomerative coefficient} (aka \dQuote{divisive
	 *   coefficient} for \code{\link{diana}}), measuring the
	 * clustering structure of the dataset.
	 *
	 * For each observation i, denote by \eqn{{m(i)}} its dissimilarity to the
	 * first cluster it is merged with, divided by the dissimilarity of the
	 * merger in the final step of the algorithm.  The agglomerative
	 * coefficient is the average of all \eqn{{1 - m(i)}}.  It can also be seen
	 * as the average width (or the percentage filled) of the banner plot.
	 *
	 * \code{coefHier()} directly interfaces to the underlying C code, and
	 * \dQuote{proves} that \emph{only} \code{object$heights} is needed to
	 * compute the coefficient.
	 *
	 * Because it grows with the number of observations, this measure should not
	 * be used to compare datasets of very different sizes.
	 *
	 */
	exported function "coef.hclust"("object", "...")
	/**
	 * 
	 * Computes the \dQuote{agglomerative coefficient} (aka \dQuote{divisive
	 *   coefficient} for \code{\link{diana}}), measuring the
	 * clustering structure of the dataset.
	 *
	 * For each observation i, denote by \eqn{{m(i)}} its dissimilarity to the
	 * first cluster it is merged with, divided by the dissimilarity of the
	 * merger in the final step of the algorithm.  The agglomerative
	 * coefficient is the average of all \eqn{{1 - m(i)}}.  It can also be seen
	 * as the average width (or the percentage filled) of the banner plot.
	 *
	 * \code{coefHier()} directly interfaces to the underlying C code, and
	 * \dQuote{proves} that \emph{only} \code{object$heights} is needed to
	 * compute the coefficient.
	 *
	 * Because it grows with the number of observations, this measure should not
	 * be used to compare datasets of very different sizes.
	 *
	 */
	function "coef.twins"("object", "...")
	/**
	 * 
	 * Computes the \dQuote{agglomerative coefficient} (aka \dQuote{divisive
	 *   coefficient} for \code{\link{diana}}), measuring the
	 * clustering structure of the dataset.
	 *
	 * For each observation i, denote by \eqn{{m(i)}} its dissimilarity to the
	 * first cluster it is merged with, divided by the dissimilarity of the
	 * merger in the final step of the algorithm.  The agglomerative
	 * coefficient is the average of all \eqn{{1 - m(i)}}.  It can also be seen
	 * as the average width (or the percentage filled) of the banner plot.
	 *
	 * \code{coefHier()} directly interfaces to the underlying C code, and
	 * \dQuote{proves} that \emph{only} \code{object$heights} is needed to
	 * compute the coefficient.
	 *
	 * Because it grows with the number of observations, this measure should not
	 * be used to compare datasets of very different sizes.
	 *
	 */
	exported function "coefHier"("object")
	/**
	 * 
	 * Compute all the pairwise dissimilarities (distances) between observations
	 * in the data set.  The original variables may be of mixed types.  In
	 * that case, or whenever \code{metric = "gower"} is set, a
	 * generalization of Gower's formula is used, see \sQuote{Details}
	 * below.
	 *
	 */
	exported function "daisy"("x", "metric"="c(\"euclidean\", \"manhattan\", \"gower\")", "stand"="FALSE", "type"="list()", "weights"="rep.int(1, p)")
	/**
	 * 
	 * Computes a divisive hierarchical clustering of the dataset
	 * returning an object of class \code{diana}.
	 *
	 */
	exported function "diana"("x", "diss"="inherits(x, \"dist\")", "metric"="euclidean", "stand"="FALSE", "keep.diss"="n < 100", "keep.data"="!diss", "trace.lev"="0")
	var "dissiCl"
	function "doExtras"()
	var "dysta"
	var "dysta3"
	/**
	 * 
	 * Compute the \dQuote{ellipsoid hull} or \dQuote{spanning ellipsoid}, i.e. the
	 * ellipsoid of minimal volume (\sQuote{area} in 2D) such that all given points
	 * lie just inside or on the boundary of the ellipsoid.
	 *
	 */
	exported function "ellipsoidhull"("x", "tol"="0.01", "maxit"="5000", "ret.wt"="FALSE", "ret.sqdist"="FALSE", "ret.pr"="FALSE")
	/**
	 * 
	 * Compute points on the ellipsoid boundary, mostly for drawing.
	 *
	 */
	exported function "ellipsoidPoints"("A", "d2", "loc", "n.half"="201")
	/**
	 * 
	 * Computes a fuzzy clustering of the data into \code{k} clusters.
	 *
	 */
	exported function "fanny"("x", "k", "diss"="inherits(x, \"dist\")", "memb.exp"="2", "metric"="c(\"euclidean\", \"manhattan\", \"SqEuclidean\")", "stand"="FALSE", "iniMem.p"="", "cluster.only"="FALSE", "keep.diss"="!diss && !cluster.only && n < 100", "keep.data"="!diss && !cluster.only", "maxit"="500", "tol"="1e-15", "trace.lev"="0")
	/**
	 * 
	 * Compute index vectors for extracting or reordering of lower or upper
	 * triangular matrices that are stored as contiguous vectors.
	 *
	 */
	exported function "lower.to.upper.tri.inds"("n")
	/**
	 * 
	 * \code{clusGap()} calculates a goodness of clustering measure, the
	 * \dQuote{gap} statistic.  For each number of clusters \eqn{{k}}, it
	 * compares \eqn{{\log(W(k))}{log(W(k))}} with
	 * \eqn{{E^*[\log(W(k))]}{E*[log(W(k))]}} where the latter is defined via
	 * bootstrapping, i.e., simulating from a reference distribution (a
	 * uniform distribution on the hypercube determined by the ranges of the first centered,
	 * and then \code{\link{svd}}-rotated \code{x}).
	 *
	 * \code{maxSE(f, SE.f)} determines the location of the \bold{maximum}
	 * of \code{f}, taking a \dQuote{1-SE rule} into account for the
	 * \code{*SE*} methods.  The default method \code{"firstSEmax"} looks for
	 * the smallest \eqn{{k}} such that its value \eqn{{f(k)}} is not more than 1
	 * standard error away from the first local maximum.
	 * This is similar but not the same as \code{"Tibs2001SEmax"}, Tibshirani
	 * et al's recommendation of determining the number of clusters from the
	 * gap statistics and their standard deviations.
	 *
	 */
	exported function "maxSE"("f", "SE.f", "method"="c(\"firstSEmax\", \"Tibs2001SEmax\", \"globalSEmax\", \"firstmax\", \"globalmax\")", "SE.factor"="1")
	/**
	 * 
	 * Internal cluster functions.
	 *
	 */
	exported function "meanabsdev"("y")
	function "mkCheckX"("x", "diss")
	/**
	 * 
	 * Returns a list representing a divisive hierarchical clustering of
	 * a dataset with binary variables only.
	 *
	 */
	exported function "mona"("x")
	/**
	 * 
	 * Partitioning (clustering) of the data into \code{k} clusters \dQuote{around
	 * medoids}, a more robust version of K-means.
	 *
	 */
	exported function "pam"("x", "k", "diss"="inherits(x, \"dist\")", "metric"="euclidean", "medoids"="", "stand"="FALSE", "cluster.only"="FALSE", "do.swap"="TRUE", "keep.diss"="!diss && !cluster.only && n < 100", "keep.data"="!diss && !cluster.only", "pamonce"="FALSE", "trace.lev"="0")
	/**
	 * 
	 * Creates plots for visualizing an \code{agnes} object.
	 *
	 */
	function "plot.agnes"("x", "ask"="FALSE", "which.plots"="", "main"="", "sub"="paste(\"Agglomerative Coefficient = \", round(x$ac, digits = 2))", "adj"="0", "nmax.lab"="35", "max.strlen"="5", "xax.pretty"="TRUE", "...")
	/**
	 * 
	 * \code{clusGap()} calculates a goodness of clustering measure, the
	 * \dQuote{gap} statistic.  For each number of clusters \eqn{{k}}, it
	 * compares \eqn{{\log(W(k))}{log(W(k))}} with
	 * \eqn{{E^*[\log(W(k))]}{E*[log(W(k))]}} where the latter is defined via
	 * bootstrapping, i.e., simulating from a reference distribution (a
	 * uniform distribution on the hypercube determined by the ranges of the first centered,
	 * and then \code{\link{svd}}-rotated \code{x}).
	 *
	 * \code{maxSE(f, SE.f)} determines the location of the \bold{maximum}
	 * of \code{f}, taking a \dQuote{1-SE rule} into account for the
	 * \code{*SE*} methods.  The default method \code{"firstSEmax"} looks for
	 * the smallest \eqn{{k}} such that its value \eqn{{f(k)}} is not more than 1
	 * standard error away from the first local maximum.
	 * This is similar but not the same as \code{"Tibs2001SEmax"}, Tibshirani
	 * et al's recommendation of determining the number of clusters from the
	 * gap statistics and their standard deviations.
	 *
	 */
	function "plot.clusGap"("x", "type"="b", "xlab"="k", "ylab"="expression(Gap[k])", "do.arrows"="TRUE", "arrowArgs"="list(col = \"red3\", length = 1/16, angle = 90, code = 3)", "...")
	/**
	 * 
	 * Creates plots for visualizing a \code{diana} object.
	 *
	 */
	function "plot.diana"("x", "ask"="FALSE", "which.plots"="", "main"="", "sub"="paste(\"Divisive Coefficient = \", round(x$dc, digits = 2))", "adj"="0", "nmax.lab"="35", "max.strlen"="5", "xax.pretty"="TRUE", "...")
	/**
	 * 
	 * Creates the banner of a \code{mona} object.
	 *
	 */
	function "plot.mona"("x", "main"="paste(\"Banner of \", deparse(x$call))", "sub"="", "xlab"="Separation step", "col"="c(2, 0)", "axes"="TRUE", "adj"="0", "nmax.lab"="35", "max.strlen"="5", "...")
	/**
	 * Creates plots for visualizing a \code{partition} object.
	 */
	function "plot.partition"("x", "ask"="FALSE", "which.plots"="", "nmax.lab"="40", "max.strlen"="5", "data"="x$data", "dist"="", "stand"="FALSE", "lines"="2", "shade"="FALSE", "color"="FALSE", "labels"="0", "plotchar"="TRUE", "span"="TRUE", "xlim"="", "ylim"="", "main"="", "...")
	/**
	 * 
	 * Compute silhouette information according to a given clustering in
	 * \eqn{{k}} clusters.
	 *
	 */
	function "plot.silhouette"("x", "nmax.lab"="40", "max.strlen"="5", "main"="", "sub"="", "xlab"="expression(\"Silhouette width \" * s[i])", "col"="gray", "do.col.sort"="length(col) > 1", "border"="0", "cex.names"="par(\"cex.axis\")", "do.n.k"="TRUE", "do.clus.stat"="TRUE", "...")
	/**
	 * 
	 * \code{pltree()} Draws a clustering tree (\dQuote{dendrogram}) on the
	 * current graphics device.  We provide the \code{twins} method draws the
	 * tree of a \code{twins} object, i.e., hierarchical clustering,
	 * typically resulting from \code{\link{agnes}()} or \code{\link{diana}()}.
	 *
	 */
	exported function "pltree"("x", "...")
	/**
	 * 
	 * \code{pltree()} Draws a clustering tree (\dQuote{dendrogram}) on the
	 * current graphics device.  We provide the \code{twins} method draws the
	 * tree of a \code{twins} object, i.e., hierarchical clustering,
	 * typically resulting from \code{\link{agnes}()} or \code{\link{diana}()}.
	 *
	 */
	function "pltree.twins"("x", "main"="paste(\"Dendrogram of \", deparse(x$call))", "labels"="", "ylab"="Height", "...")
	/**
	 * 
	 * Compute points on the ellipsoid boundary, mostly for drawing.
	 *
	 */
	exported function "predict.ellipsoid"("object", "n.out"="201", "...")
	/**
	 * 
	 * Prints the call, agglomerative coefficient, ordering of objects and
	 * distances between merging clusters (`Height') of an \code{agnes} object.
	 *
	 * This is a method for the generic \code{\link{print}()} function for objects
	 * inheriting from class \code{agnes}, see \code{\link{agnes.object}}.
	 *
	 */
	function "print.agnes"("x", "...")
	/**
	 * 
	 * Prints the best sample, medoids, clustering vector and objective function
	 * of \code{clara} object.
	 *
	 * This is a method for the function \code{\link{print}()} for objects
	 * inheriting from class \code{\link{clara}}.
	 *
	 */
	function "print.clara"("x", "...")
	/**
	 * 
	 * \code{clusGap()} calculates a goodness of clustering measure, the
	 * \dQuote{gap} statistic.  For each number of clusters \eqn{{k}}, it
	 * compares \eqn{{\log(W(k))}{log(W(k))}} with
	 * \eqn{{E^*[\log(W(k))]}{E*[log(W(k))]}} where the latter is defined via
	 * bootstrapping, i.e., simulating from a reference distribution (a
	 * uniform distribution on the hypercube determined by the ranges of the first centered,
	 * and then \code{\link{svd}}-rotated \code{x}).
	 *
	 * \code{maxSE(f, SE.f)} determines the location of the \bold{maximum}
	 * of \code{f}, taking a \dQuote{1-SE rule} into account for the
	 * \code{*SE*} methods.  The default method \code{"firstSEmax"} looks for
	 * the smallest \eqn{{k}} such that its value \eqn{{f(k)}} is not more than 1
	 * standard error away from the first local maximum.
	 * This is similar but not the same as \code{"Tibs2001SEmax"}, Tibshirani
	 * et al's recommendation of determining the number of clusters from the
	 * gap statistics and their standard deviations.
	 *
	 */
	function "print.clusGap"("x", "method"="firstSEmax", "SE.factor"="1", "...")
	/**
	 * 
	 * Prints the ordering of objects, diameters of splitted clusters,
	 * and divisive coefficient of a \code{diana} object.
	 *
	 * This is a method for the function \code{\link{print}()} for objects
	 * inheriting from class \code{\link{diana}}.
	 *
	 */
	function "print.diana"("x", "...")
	/**
	 * 
	 * Print or summarize the distances and the attributes of a
	 * \code{dissimilarity} object.
	 *
	 * These are methods for the functions \code{print()} and \code{summary()} for
	 * \code{dissimilarity} objects.  See \code{print}, \code{print.default},
	 * or \code{summary} for the general behavior of these.
	 *
	 */
	function "print.dissimilarity"("x", "diag"="", "upper"="", "digits"="getOption(\"digits\")", "justify"="none", "right"="TRUE", "...")
	/**
	 * 
	 * Compute the \dQuote{ellipsoid hull} or \dQuote{spanning ellipsoid}, i.e. the
	 * ellipsoid of minimal volume (\sQuote{area} in 2D) such that all given points
	 * lie just inside or on the boundary of the ellipsoid.
	 *
	 */
	function "print.ellipsoid"("x", "digits"="max(1, getOption(\"digits\") - 2)", "...")
	/**
	 * 
	 * Prints the objective function, membership coefficients and clustering vector
	 * of \code{fanny} object.
	 *
	 * This is a method for the function \code{\link{print}()} for objects
	 * inheriting from class \code{\link{fanny}}.
	 *
	 */
	function "print.fanny"("x", "digits"="getOption(\"digits\")", "...")
	/**
	 * 
	 * Prints the ordering of objects, separation steps, and used variables
	 * of a \code{mona} object.
	 *
	 * This is a method for the function \code{\link{print}()} for objects
	 * inheriting from class \code{\link{mona}}.
	 *
	 */
	function "print.mona"("x", "...")
	/**
	 * 
	 * Prints the medoids, clustering vector and objective function
	 * of \code{pam} object.
	 *
	 * This is a method for the function \code{\link{print}()} for objects
	 * inheriting from class \code{\link{pam}}.
	 *
	 */
	function "print.pam"("x", "...")
	/**
	 * 
	 * Returns (and prints) a summary list for an \code{agnes} object.
	 * Printing gives more output than the corresponding
	 * \code{\link{print.agnes}} method.
	 *
	 */
	function "print.summary.agnes"("x", "...")
	/**
	 * 
	 * Returns (and prints) a summary list for a \code{clara} object.
	 * Printing gives more output than the corresponding
	 * \code{\link{print.clara}} method.
	 *
	 */
	function "print.summary.clara"("x", "...")
	/**
	 * Returns (and prints) a summary list for a \code{diana} object.
	 */
	function "print.summary.diana"("x", "...")
	/**
	 * 
	 * Print or summarize the distances and the attributes of a
	 * \code{dissimilarity} object.
	 *
	 * These are methods for the functions \code{print()} and \code{summary()} for
	 * \code{dissimilarity} objects.  See \code{print}, \code{print.default},
	 * or \code{summary} for the general behavior of these.
	 *
	 */
	function "print.summary.dissimilarity"("x", "...")
	/**
	 * 
	 * Prints the objective function, membership coefficients and clustering vector
	 * of \code{fanny} object.
	 *
	 * This is a method for the function \code{\link{print}()} for objects
	 * inheriting from class \code{\link{fanny}}.
	 *
	 */
	function "print.summary.fanny"("x", "digits"="getOption(\"digits\")", "...")
	/**
	 * Returns (and prints) a summary list for a \code{mona} object.
	 */
	function "print.summary.mona"("x", "...")
	/**
	 * Summarize a \code{\link{pam}} object and return an object
	 * of class \code{summary.pam}.
	 * There's a \code{\link{print}} method for the latter.
	 *
	 */
	function "print.summary.pam"("x", "...")
	/**
	 * 
	 * Compute silhouette information according to a given clustering in
	 * \eqn{{k}} clusters.
	 *
	 */
	function "print.summary.silhouette"("x", "...")
	var "R_bncoef"
	var "sildist"
	/**
	 * 
	 * Compute silhouette information according to a given clustering in
	 * \eqn{{k}} clusters.
	 *
	 */
	exported function "silhouette"("x", "...")
	/**
	 * 
	 * Compute silhouette information according to a given clustering in
	 * \eqn{{k}} clusters.
	 *
	 */
	function "silhouette.clara"("x", "full"="FALSE", "...")
	/**
	 * 
	 * Compute silhouette information according to a given clustering in
	 * \eqn{{k}} clusters.
	 *
	 */
	function "silhouette.default"("x", "dist", "dmatrix", "...")
	function "silhouette.default.R"("x", "dist", "dmatrix", "...")
	/**
	 * 
	 * Compute silhouette information according to a given clustering in
	 * \eqn{{k}} clusters.
	 *
	 */
	function "silhouette.partition"("x", "...")
	/**
	 * 
	 * Returns the number of observations (\emph{sample size}) corresponding
	 * to a  dissimilarity like object, or equivalently,
	 * the number of rows or columns of a matrix
	 * when only the lower or upper triangular part (without diagonal) is given.
	 *
	 * It is nothing else but the inverse function of \eqn{{f(n) = n(n-1)/2}}.
	 *
	 */
	exported function "sizeDiss"("d")
	/**
	 * 
	 * Compute silhouette information according to a given clustering in
	 * \eqn{{k}} clusters.
	 *
	 */
	exported function "sortSilhouette"("object", "...")
	var "spannel"
	/**
	 * 
	 * Returns (and prints) a summary list for an \code{agnes} object.
	 * Printing gives more output than the corresponding
	 * \code{\link{print.agnes}} method.
	 *
	 */
	function "summary.agnes"("object", "...")
	/**
	 * 
	 * Returns (and prints) a summary list for a \code{clara} object.
	 * Printing gives more output than the corresponding
	 * \code{\link{print.clara}} method.
	 *
	 */
	function "summary.clara"("object", "...")
	/**
	 * Returns (and prints) a summary list for a \code{diana} object.
	 */
	function "summary.diana"("object", "...")
	/**
	 * 
	 * Print or summarize the distances and the attributes of a
	 * \code{dissimilarity} object.
	 *
	 * These are methods for the functions \code{print()} and \code{summary()} for
	 * \code{dissimilarity} objects.  See \code{print}, \code{print.default},
	 * or \code{summary} for the general behavior of these.
	 *
	 */
	function "summary.dissimilarity"("object", "digits"="max(3, getOption(\"digits\") - 2)", "...")
	/**
	 * 
	 * Prints the objective function, membership coefficients and clustering vector
	 * of \code{fanny} object.
	 *
	 * This is a method for the function \code{\link{print}()} for objects
	 * inheriting from class \code{\link{fanny}}.
	 *
	 */
	function "summary.fanny"("object", "...")
	/**
	 * Returns (and prints) a summary list for a \code{mona} object.
	 */
	function "summary.mona"("object", "...")
	/**
	 * Summarize a \code{\link{pam}} object and return an object
	 * of class \code{summary.pam}.
	 * There's a \code{\link{print}} method for the latter.
	 *
	 */
	function "summary.pam"("object", "...")
	/**
	 * 
	 * Compute silhouette information according to a given clustering in
	 * \eqn{{k}} clusters.
	 *
	 */
	function "summary.silhouette"("object", "FUN", "...")
	function "toCrisp"("m")
	/**
	 * 
	 * The objects of class \code{"twins"} represent an agglomerative or
	 * divisive (polythetic) hierarchical clustering of a dataset.
	 *
	 */
	var "twins"
	/**
	 * 
	 * Compute index vectors for extracting or reordering of lower or upper
	 * triangular matrices that are stored as contiguous vectors.
	 *
	 */
	exported function "upper.to.lower.tri.inds"("n")
	/**
	 * 
	 * Compute the volume of a planar object.
	 * This is a generic function and a method for \code{ellipsoid} objects.
	 *
	 */
	exported function "volume"("object")
	/**
	 * 
	 * Compute the volume of a planar object.
	 * This is a generic function and a method for \code{ellipsoid} objects.
	 *
	 */
	function "volume.ellipsoid"("object")
}
