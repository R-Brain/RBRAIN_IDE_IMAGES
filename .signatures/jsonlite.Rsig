package "jsonlite" "0.9.22" {
	var ".__C__AsIs"
	var ".__C__integer64"
	var ".__C__json"
	var ".__C__pairlist"
	var ".__C__scalar"
	var ".__NAMESPACE__."
	var ".__S3MethodsTable__."
	var ".__T__asJSON:jsonlite"
	var ".packageName"
	var ".S3MethodsClasses"
	function "all.identical"("x")
	function "apply_by_pages"("x", "FUN", "pagesize", "verbose", "...")
	function "apply_by_pages2"("x", "FUN", "pagesize", "verbose", "...")
	function "as.scalar"("obj")
	function "asJSON"("x", "...")
	function "base64_decode"("input")
	function "base64_encode"("input")
	var "C_collapse_array"
	var "C_collapse_array_pretty_inner"
	var "C_collapse_array_pretty_outer"
	var "C_collapse_object"
	var "C_collapse_object_pretty"
	var "C_escape_chars"
	var "C_is_recordlist"
	var "C_is_scalarlist"
	var "C_null_to_na"
	var "C_row_collapse_array"
	var "C_row_collapse_object"
	function "cleannames"("objnames")
	function "collapse"("x", "inner"="TRUE", "indent"="0")
	function "collapse_array"("x", "columnmajor"="FALSE", "indent")
	function "collapse_object"("x", "y", "indent"="0")
	function "deparse_vector"("x")
	function "deparse_vector_c"("x")
	function "deparse_vector_old"("x")
	function "deparse_vector_r"("x")
	function "evaltext"("text")
	function "feed_push_parser"("data", "reset"="FALSE")
	function "finalize_push_parser"("bigint_as_char")
	function "fixNativeSymbol"("symbol")
	/**
	 * 
	 *In a nested data frame, one or more of the columns consist of another data
	 *frame. These structures frequently appear when parsing JSON data from the web.
	 *We can flatten such data frames into a regular 2 dimensional tabular structure.
	 *
	 */
	exported function "flatten"("x", "recursive"="TRUE")
	/**
	 * 
	 *These functions are used to convert between JSON data and \R{}LIST{} objects. The \code{\link{toJSON}} and \code{\link{fromJSON}}
	 *functions use a class based mapping, which follows conventions outlined in this paper:  \url{http://arxiv.org/abs/1403.2805} (also available as vignette).
	 *
	 */
	exported function "fromJSON"("txt", "simplifyVector"="TRUE", "simplifyDataFrame", "simplifyMatrix", "flatten"="FALSE", "...")
	function "fromJSON_string"("txt", "simplifyVector"="TRUE", "simplifyDataFrame", "simplifyMatrix", "flatten"="FALSE", "unicode"="TRUE", "validate"="TRUE", "bigint_as_char"="FALSE", "...")
	function "givename"("obj")
	function "integer64_to_char"("x", "na_as_string"="TRUE")
	function "is_recordlist_c"("x")
	function "is_recordlist_r"("x")
	function "is_scalarlist_c"("x")
	function "is_scalarlist_r"("x")
	function "is.arraylist"("x")
	function "is.datelist"("x")
	function "is.matrixlist"("x")
	function "is.namedlist"("x")
	function "is.namedlistnotdf"("x")
	function "is.recordlist"("x")
	function "is.scalarlist"("x")
	function "is.unnamedlist"("x")
	function "list_to_vec"("x")
	function "loadpkg"("pkg")
	function "makesymbol"("x")
	/**
	 * 
	 *Prettify adds indentation to a JSON string; minify removes all indentation/whitespace.
	 *
	 */
	exported function "minify"("txt")
	function "null_to_na"("x")
	function "null_to_na_c"("x")
	function "null_to_na_r"("x")
	function "num_to_char"("x", "digits"="NA", "na_as_string"="NA", "use_signif"="FALSE", "always_decimal"="FALSE")
	function "num_to_char_R"("x", "digits"="NA", "na_as_string"="NA")
	function "pack"("obj", "...")
	function "parse_con"("con", "n", "bigint_as_char")
	function "parse_string"("txt", "bigint_as_char")
	function "parseJSON"("txt", "bigint_as_char"="FALSE")
	function "post_process"("x")
	/**
	 * 
	 *Prettify adds indentation to a JSON string; minify removes all indentation/whitespace.
	 *
	 */
	exported function "prettify"("txt", "indent"="4")
	function "print.json"("x", "...")
	function "print.scalar"("x", "...")
	var "R_base64_decode"
	var "R_base64_encode"
	var "R_feed_push_parser"
	var "R_finalize_push_parser"
	var "R_integer64_to_char"
	var "R_num_to_char"
	var "R_parse"
	var "R_reformat"
	var "R_validate"
	function "raw_to_json"("x")
	/**
	 * 
	 *The \code{rbind.pages} function is used to combine a list of data frames into a single
	 *data frame. This is often needed when working with a JSON API that limits the amount
	 *of data per request. If we need more data than what fits in a single request, we need to
	 *perform multiple requests that each retrieve a fragment of data, not unlike pages in a
	 *book. In practice this is often implemented using a \code{page} parameter in the API. The
	 *\code{rbind.pages} function can be used to combine these pages back into a single dataset.
	 *
	 */
	exported function "rbind.pages"("pages")
	function "reformat"("x", "pretty", "indent_string"="")
	function "row_collapse"("m", "indent"="NA")
	function "row_collapse_object"("x", "m", "indent"="NA")
	function "S4tolist"("x")
	/**
	 * 
	 *The \code{\link{serializeJSON}} and \code{\link{unserializeJSON}} functions convert between
	 *\R{}LIST{} objects to JSON data. Instead of using a class based mapping like
	 *\code{\link{toJSON}} and \code{\link{fromJSON}}, the serialize functions base the encoding
	 *schema on the storage type, and capture all data and attributes from any object.
	 *Thereby the object can be restored almost perfectly from its JSON representation, but
	 *the resulting JSON output is very verbose. Apart from environments, all standard storage
	 *types are supported.
	 *
	 */
	exported function "serializeJSON"("x", "digits"="8", "pretty"="FALSE")
	function "simplify"("x", "simplifyVector"="TRUE", "simplifyDataFrame"="TRUE", "simplifyMatrix"="TRUE", "simplifyDate", "homoList"="TRUE", "flatten"="FALSE", "columnmajor"="FALSE", "simplifySubMatrix")
	function "simplifyDataFrame"("recordlist", "columns", "flatten", "simplifyMatrix")
	function "stop"("...", "call."="FALSE")
	/**
	 * 
	 *The \code{stream_in} and \code{stream_out} functions implement line-by-line processing
	 *of JSON data over a \code{\link{connection}}, such as a socket, url, file or pipe. JSON
	 *streaming requires the \href{{http://ndjson.org}{ndjson}} format, which slightly differs
	 *from \code{\link{fromJSON}} and \code{\link{toJSON}}, see details.
	 *
	 */
	exported function "stream_in"("con", "handler"="", "pagesize"="500", "verbose"="TRUE", "...")
	/**
	 * 
	 *The \code{stream_in} and \code{stream_out} functions implement line-by-line processing
	 *of JSON data over a \code{\link{connection}}, such as a socket, url, file or pipe. JSON
	 *streaming requires the \href{{http://ndjson.org}{ndjson}} format, which slightly differs
	 *from \code{\link{fromJSON}} and \code{\link{toJSON}}, see details.
	 *
	 */
	exported function "stream_out"("x", "con"="stdout()", "pagesize"="500", "verbose"="TRUE", "...")
	function "stream_out_page"("page", "con", "...")
	/**
	 * 
	 *These functions are used to convert between JSON data and \R{}LIST{} objects. The \code{\link{toJSON}} and \code{\link{fromJSON}}
	 *functions use a class based mapping, which follows conventions outlined in this paper:  \url{http://arxiv.org/abs/1403.2805} (also available as vignette).
	 *
	 */
	exported function "toJSON"("x", "dataframe"="c(\"rows\", \"columns\", \"values\")", "matrix"="c(\"rowmajor\", \"columnmajor\")", "Date"="c(\"ISO8601\", \"epoch\")", "POSIXt"="c(\"string\", \"ISO8601\", \"epoch\", \"mongo\")", "factor"="c(\"string\", \"integer\")", "complex"="c(\"string\", \"list\")", "raw"="c(\"base64\", \"hex\", \"mongo\")", "null"="c(\"list\", \"null\")", "na"="c(\"null\", \"string\")", "auto_unbox"="FALSE", "digits"="4", "pretty"="FALSE", "force"="FALSE", "...")
	function "trim"("x")
	/**
	 * 
	 *This function marks an atomic vector or data frame as a
	 *\href{{http://en.wikipedia.org/wiki/Singleton_(mathematics)}{singleton}}, i.e.
	 *a set with exactly 1 element. Thereby, the value will not turn into an
	 *\code{array} when encoded into JSON. This can only be done for
	 *atomic vectors of length 1, or data frames with exactly 1 row. To automatically
	 *unbox all vectors of length 1 within an object, use the \code{auto_unbox} argument
	 *in \code{\link{toJSON}}.
	 *
	 */
	exported function "unbox"("x")
	function "unescape_unicode"("x")
	function "unpack"("obj")
	/**
	 * 
	 *The \code{\link{serializeJSON}} and \code{\link{unserializeJSON}} functions convert between
	 *\R{}LIST{} objects to JSON data. Instead of using a class based mapping like
	 *\code{\link{toJSON}} and \code{\link{fromJSON}}, the serialize functions base the encoding
	 *schema on the storage type, and capture all data and attributes from any object.
	 *Thereby the object can be restored almost perfectly from its JSON representation, but
	 *the resulting JSON output is very verbose. Apart from environments, all standard storage
	 *types are supported.
	 *
	 */
	exported function "unserializeJSON"("txt")
	function "utf8conv"("x")
	/**
	 * 
	 *Test if a string contains valid JSON. Characters vectors will be collapsed into a single string.
	 *
	 */
	exported function "validate"("txt")
	function "warn_keep_vec_names"()
	function "wrapinquotes"("x")
}
